# 1MySQL

> `MySQL`是一种关系型数据库管理系统（`RDBMS`），广泛应用于各种应用程序和网站的数据存储和管理。MySQL由瑞典公司MySQL AB开发，被Sun Microsystems收购，最终由Oracle Corporation管理和维护

## 1.1 MySQL特点

> 1. 数据模型 ：MySQL是基于关系模型的数据库管理系统，使用表格存储数据。表由列组成，每列定义数据的类型和约束。通过在表之间建立关系，实现数据的关联和查询
> 
> 2. SQL语言支持 ：MySQL支持标准的结构化查询语言，用于管理和操作数据库，可以创建和修改表结构，插入、更新和删除数据，以及执行各种查询操作，支持存储过程、触发器和视图等高级数据库功能
> 
> 3. 多用户和并发控制 ：MySQL支持多用户访问数据库，并提供了并发控制机制来处理多个用户同时对数据库进行读写操作的情况。通过事务和锁机制，MySQL可以确保数据的一致性和完整性
> 
> 4. 存储引擎 ：MySQL支持多种存储引擎，用于实际存储和管理数据。最常用的是InnoDB引擎，它提供了ACID事务支持和高并发性能。MySQL还支持MyISAM、Memory、CSV等存储引擎
> 
> 5. 可扩展性 ：MySQL具有良好的可扩展性，可以处理大规模的数据和高并发访问。通过主从复制和分片等技术，可以将负载分布到多个服务器上，提高系统的吞吐量和可用性

## 1.2 MySQL 组成

### 1.2.1 MySQL服务器（MySQL Server）

> MySQL核心组件，负责处理客户端的连接请求、执行SQL语句、管理数据库和数据

### 1.2.2 存储引擎（Storage Engines）

> 存储引擎用于实际的数据存储和检索，常见的存储引擎包括：
> 
> 1. InnoDB：默认的事务性存储引擎，支持事务和行级锁定，提供高性能和数据完整性
> 
> 2. MyISAM：传统的非事务性存储引擎，适用于读密集型应用，不支持事务和行级锁定
> 
> 3. Memory：将数据存储在内存中，适用于对速度要求较高的临时数据存储
> 
> 4. Archive：用于存储和检索大量历史数据，提供高压缩比和低存储成本

### 1.2.3 客户端工具（Client Tools）

> 客户端工具用于连接和管理MySQL服务器，常见的客户端工具包括：
> 
> 1. `MySQL` 命令行客户端：通过命令行界面与 `MySQL` 服务器进行交互，执行SQL语句、管理数据库和用户
> 
> 2. `MySQL Workbench` ：图形化的数据库设计和管理工具，提供可视化界面来管理数据库、执行查询和调优等操作
> 
> 3. `phpMyAdmin`：基于Web的MySQL管理工具，通过浏览器访问，提供图形化界面来管理数据库

### 1.2.4 连接器（Connector）

> 连接器用于与不同编程语言和平台进行连接和交互，常见的连接器包括：
> 
> 1. MySQL Connector/J：用于Java应用程序的连接器
> 
> 2. MySQL Connector/ODBC：用于ODBC兼容的应用程序的连接器
> 
> 3. MySQL Connector/NET：用于.NET应用程序的连接器

### 1.2.5 连接池（Connection Pool）

> 连接池是一种管理和复用数据库连接的技术，可以提高应用程序与数据库之间的性能和可伸缩性。连接池通过预先创建一组数据库连接并将其保存在池中，应用程序可以从池中获取连接并在使用完毕后将其归还给池，以便其他线程或请求可以继续复用该连接
> 
> 1. 性能提升 ：连接池可以避免频繁地创建和销毁数据库连接，从而减少了连接的创建和认证开销，提高了数据库操作的性能
> 
> 2. 资源管理 ：连接池可以限制同时打开的连接数，确保数据库连接资源的合理利用，避免因为过多的连接而导致数据库性能下降或资源耗尽的问题
> 
> 3. 连接复用 ：连接池可以重复使用已经建立的连接，避免了每次执行数据库操作都需要重新建立连接的开销，提高了数据库操作的效率

### 1.2.6 解析器（Parser）

> 解析器负责解析和分析SQL语句，将输入的SQL语句转换为内部数据结构，以便数据库系统可以理解和执行这些语句
> 
> 1. 词法分析（Lexical Analysis）：解析器将输入的SQL语句分解为一个个的词法单元（tokens），如关键字、标识符、运算符、常量等
> 
> 2. 语法分析（Syntax Analysis）：在词法分析的基础上，解析器根据SQL语句的语法规则进行语法分析。它将词法单元组织成语法树（Parse Tree）或抽象语法树（Abstract Syntax Tree，AST），表示SQL语句的结构和语义
> 
> 3. 语义分析（Semantic Analysis）：解析器对语法树进行语义分析，验证SQL语句的语义正确性。它检查表名、列名等标识符的存在性和合法性，进行类型检查，以及应用数据库系统的约束规则
> 
> 4. 查询优化（Query Optimization）：在解析过程中，解析器还可以对表达式进行常量折叠、条件简化等优化操作，以提高查询的执行效率

### 1.2.7 查询优化器（Optimizer）

> 查询优化器负责分析和优化查询语句，以生成最佳的执行计划，目标是选择最有效的执行策略，以最小化查询的执行成本并提高查询性能
> 
> 1. 查询重写（Query Rewriting）：优化器对查询语句进行重写，以便更好地利用索引和其他优化技术
> 
> 2. 最佳访问路径（Access Path Selection）：优化器会评估不同的访问路径，例如全表扫描、索引扫描、联接等，考虑各种因素，如索引的选择性、表的大小、数据分布等，以选择最高效的访问方式选择最佳的访问路径获取数据
> 
> 3. 连接顺序优化（Join Order Optimization）：涉及多表查询时，优化器会尝试不同的表连接顺序，并评估每种连接顺序的成本，选择最佳的连接顺序，以减少连接操作的开销
> 
> 4. 子查询优化（Subquery Optimization）：优化器会对子查询进行优化，通过将子查询转换为连接操作或使用适当的优化技术来改进查询性能，以减少子查询的执行次数和开销
> 
> 5. 表达式优化（Expression Optimization）：优化器会对查询中的表达式进行优化，例如常量折叠、条件推导、谓词下推等，减少不必要的计算和过滤操作，提高查询的执行效率
> 
> 6. 统计信息利用（Statistics Utilization）：优化器会利用收集到的统计信息，如表的大小、索引的选择性、列的分布等，来估计查询的成本和选择最佳的执行计划

## 1.3 配置MySQL

## 1.4 数据库三范式（Database Normalization）

> 数据库三范式是设计关系型数据库的规范化方法，旨在减少数据冗余、提高数据一致性和减少数据更新异常

### 1.4.1 第一范式（1NF）

>  数据库表中的<mark>字段都是单一属性的，不可再分</mark>。单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等

### 1.4.2 第二范式（2NF）

> 在满足第一范式的基础上，要求<mark>非主键列完全依赖于主键</mark>，而不是依赖于主键的一部分。若存在部分依赖，需要将相关列拆分为独立的表

### 1.4.3 第三范式（3NF）

> 在满足第二范式的基础上，要求<mark>非主键列之间不存在传递依赖</mark>。若存在传递依赖，就需要将相关列拆分为独立的表

## 1.5 结构化查询语言（Structured Query Language，SQL）

> 结构化查询语言是一种用于管理关系型数据库系统的标准化语言，提供了一套用于定义、操作和查询数据库的语法和规则

### 1.5.1 数据定义语言（Data Definition Language，DDL）

> `DDL` 用于定义和管理数据库的结构和模式，包括创建、修改和删除数据库对象
> 
> - `CREATE`：用于创建数据库对象，如创建表、视图、索引等
> - `ALTER`：用于修改数据库对象的结构，如修改表结构、添加列等 
> - `DROP`：用于删除数据库对象，如删除表、视图、索引等

### 1.5.2 数据操作语言（Data Manipulation Language，DML）

> `DML` 用于对数据库中的数据进行操作，包括查询、插入、更新和删除数据
> 
> - `SELECT`：用于从数据库中查询数据
> - `INSERT`：用于向数据库中插入新的数据
> - `UPDATE`：用于更新数据库中的数据
> - `DELETE`：用于从数据库中删除数据

### 1.5.3 数据控制语言（Data Control Language，DCL）

> `DCL` 用于控制数据库的访问权限和安全性，包括授权和撤销权限的语句
> 
> - `GRANT`：用于授予用户或角色对数据库对象的访问权限
> - `REVOKE`：用于撤销用户或角色对数据库对象的访问权限

### 1.5.4 事务控制语言（Transaction Control Language，TCL）

> `TCL` 用于管理数据库中的事务处理，包括控制事务的提交和回滚操作，以及设置事务的隔离级别
> 
> - `COMMIT`：用于提交当前事务的操作
> - `ROLLBACK`：用于回滚当前事务的操作
> - `SAVEPOINT`：用于设置事务的保存点，以便在需要时回滚到保存点

## 1.6 关系模型

> 关系型数据库管理系统基于关系模型来组织和管理数据。关系模型是一种以表格（称为关系）的形式来表示数据的方法，其中每个表格包含行和列

### 1.6.1 表（Table）

> 表是关系模型中最基本的组织单位，数据存储在表中，表由行和列组成，每一列代表一个属性，每一行代表一个记录。表具有唯一的名称，并且每个表都有一个主键，用于唯一标识表中的每个记录

### 1.6.2 列（Column）

> 列也被称为字段（Field），代表表中的每个属性，每列有名称和数据类型，用于定义该列存储的数据的类型

### 1.6.3 行（Row）

> 行也被称为记录（Record），代表表中的每个实体。每行包含一组数据，每个数据对应表中的一个列。行是表中的实际数据，它存储了每个实体的属性值

### 1.6.4 主键（Primary Key）

> 每个表都有一个主键，用于唯一标识表中的每个记录。主键由一个或多个列组成，它们的值在表中必须是唯一的且非空的

### 1.6.5 外键（Foreign Key）

> 外键是一种用于在关系数据库中建立表之间关联关系的机制，是用于建立表之间关系的列，建立了一个指向其他表主键的引用，用于维护表之间的关联性。外键用于实现表之间的关系，如一对多关系、多对多关系等

### 1.6.6 索引（Index）

> 索引是一种优化技术，用于加快数据检索的速度，提高查询性能，但会增加写操作的开销

# 2 存储引擎

> 存储引擎是数据存储和检索的核心组件
> 
> 1. InnoDB ：InnoDB提供了ACID事务支持和行级锁定，支持外键、崩溃恢复和并发控制等功能
> 
> 2. MyISAM ：MyISAM不支持事务和行级锁定，但具有较快的读取速度和较低的存储空间需求，适用于读取频繁、写入较少的应用场景
> 
> 3. PostgreSQL ：PostgreSQL支持多个存储引擎，其中最常用的是默认的存储引擎称为``heap``，它是基于行的存储引擎。此外，PostgreSQL还支持其他存储引擎，如B+树索引引擎（``btree``）、哈希索引引擎（``hash``）和GIN/GiST索引引擎等
> 
> 4. Oracle Database ：Oracle数据库使用自己的存储引擎，称为Oracle数据块，采用多版本并发控制（MVCC）和行级锁定来提供高并发性和数据一致性
> 
> 5. Microsoft SQL Server ：SQL Server使用称为“页”（Page）的存储单位来组织数据，支持多种存储引擎，包括InnoDB、Federated引擎、Memory引擎
> 
> 6. SQLite ：SQLite是一种嵌入式数据库引擎，将整个数据库作为单个文件存储，支持事务、索引和SQL查询，不支持多用户并发访问

## 2.1 InnoDB

> `InnoDB`是`MySQL`数据库管理系统默认的存储引擎，提供事务支持、行级锁定、崩溃恢复和并发控制等功能

1. 事务支持 ：`InnoDB`支持`ACID`（原子性、一致性、隔离性和持久性）事务，允许将多个操作组合成一个逻辑工作单元，并要么全部提交（保持一致性），要么全部回滚（回滚到事务开始前的状态）

2. 行级锁定 ：`InnoDB`使用行级锁定来实现并发控制，在同一时间可以有多个事务同时访问表中的不同行，而不会相互阻塞。行级锁定提供了更好的并发性能，可以减少锁冲突和死锁的可能性

3. 外键支持 ：`InnoDB`支持外键约束

4. 崩溃恢复 ：`InnoDB`使用事务日志（redo log）来记录事务对数据库所做的更改，具有崩溃恢复机制，可以在数据库发生崩溃或意外关闭时恢复数据的一致性状态

5. 并发控制 ：`InnoDB`使用`MVCC`来实现高并发性。MVCC允许读取操作不会被写入操作所阻塞，同时保证读取操作的一致性视图

## 2.2 MyISAM

> MyISAM是MySQL数据库管理系统在MySQL 5.5.5版本之前的默认存储引擎

1. 表锁定 ：`MyISAM`使用表级锁定来实现并发控制，当一个事务对表进行写操作时，其他事务无法对同一表进行写操作，这可能导致并发性能下降

2. 无事务支持 ：`MyISAM`不支持事务，不提供ACID属性，无法保证数据的一致性和完整性

3. 高速读取 ：`MyISAM`使用静态行格式的存储方式，使得读取操作可以更快地执行

4. 全文索引支持 ：`MyISAM`提供良好的全文索引支持，全文索引允许在文本数据中进行高效的关键词搜索

5. 较低的存储空间需求 ：`MyISAM` 在存储数据时通常需要较少的磁盘空间。这是因为它不支持事务和行级锁定等功能，从而减少了存储开销

6. 不支持外键约束 ：`MyISAM` 不支持外键约束

## 2.3 InnoDB与MyISAM

|                                       | MyISAM                            | Innodb             |
|:-------------------------------------:|:---------------------------------:|:------------------:|
| 文件格式                                  | 数据和索引是分别存储的，数据`.MYD`，索引`.MYI`     | 数据和索引是集中存储的，`.ibd` |
| 文件能否移动                                | 能                                 | 否                  |
| 记录存储顺序                                | 按记录插入顺序保存                         | 按主键大小有序插入          |
| 空间碎片（删除记录并`flush table 表名`之后，表文件大小不变） | 产生。定时整理：使用命令`optimize table 表名`实现 | 不产生                |
| 事务                                    | 不支持                               | 支持                 |
| 外键                                    | 不支持                               | 支持                 |
| 锁支持                                   | 表级锁定                              | 行级锁定、表级锁定          |

## 2.4 存储引擎常用命令

1. 查看当前默认存储引擎：
   
   ```sql
   SHOW VARIABLES LIKE 'default_storage_engine';
   ```

2. 查看数据库中的表所使用的存储引擎：
   
   ```sql
   SHOW TABLE STATUS LIKE 'table_name';
   ```

3. 创建表时指定存储引擎：
   
   ```sql
   CREATE TABLE table_name (column1 datatype, column2 datatype, ...)
   ENGINE = storage_engine;
   ```

4. 修改表的存储引擎：
   
   ```sql
   # table_name 是要修改的表名，storage_engine 是要修改为的存储引擎名称
   ALTER TABLE table_name ENGINE = storage_engine;
   ```

5. 查看支持的存储引擎列表：
   
   ```sql
   SHOW ENGINES;
   ```

6. 查看存储引擎的详细信息：
   
   ```sql
   SHOW ENGINE engine_name STATUS; # engine_name 是存储引擎的名称
   ```

# 3 索引（Index）

> 索引是一种用于提高数据库查询效率的数据结构，帮助数据库快速定位和访问表中数据的数据结构，可以加快查询速度，减少数据库IO操作，提高数据库的性能

## 3.1 索引使用场景

1. 唯一性约束 ：唯一索引可以确保表中的某个列的数值唯一

2. 主键约束 ：主键索引用于唯一标识表中的每一行数据，提高根据主键进行数据查询和连接的性能

3. 频繁的查询操作 ：对于经常被查询的列，使用索引可以加快查询速度

4. 排序和分组操作 ：对于需要进行排序或分组的列，使用索引可以加快这些操作的速度

5. 外键约束 ：外键索引用于维护表之间的关联关系，使用外键索引可以加快关联表的连接操作，并确保引用完整性

6. 模糊查询 ： 对于模糊查询，可以通过创建合适的前缀索引来提高查询性能

## 3.2 索引的优缺点

### 3.2.1 优点

1. 提高查询性能 ：索引可以加快数据检索的速度，通过使用索引，数据库可以更快地定位到满足查询条件的数据行，减少了全表扫描的开销

2. 加速排序和分组操作 ：对于需要排序或分组的列，索引可以提高这些操作的速度。索引使得数据库可以快速定位到排序或分组的起始点，减少了数据的扫描和排序操作

3. 支持唯一性约束 ：索引可以用于确保表中某个列的数值唯一

4. 提高连接操作的性能 ：通过在关联列上创建索引，可以加快表之间连接的速度。索引可以帮助数据库快速定位到连接操作所需的数据行，减少了连接操作的开销

### 3.2.2 缺点

1. 占用存储空间 ：索引需要占用额外的存储空间

2. 增加写操作的开销 ：当进行数据的插入、更新和删除操作时，索引需要进行相应的维护操作，这会增加写操作的开销。每次修改数据时，除了要更新实际的数据行外，还需要更新索引结构，因此写操作的性能可能会受到一定影响

3. 索引需要维护 ：随着数据的修改和更新，索引也需要进行维护。当表中的数据发生变化时，索引需要进行更新，这可能导致额外的开销

4. 可能导致查询性能下降 ：如果索引被错误地设计或过度使用，可能会导致查询性能下降

## 3.3 索引分类

从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引

从应用层次来分：普通索引，唯一索引，复合索引

根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引

### 3.3.1 普通索引（Normal Index）

> 普通索引无任何特殊约束要求，只包含单个列，一个表可以有多个普通索引。普通索引可以加速对索引列的查询，允许重复值和空值

### 3.3.2 唯一索引（Unique Index）

> 唯一索引要求索引列的值在整个表中必须唯一，但允许为空值。一个表可以有多个唯一索引，索引列的值必须唯一，但允许有 null 且 null 可以出现多次。唯一索引可以用于加速唯一性约束的检查

### 3.3.3 主键索引（Primary Key Index）

> 主键索引用于唯一标识表中的每一行数据，索引列的值唯一且不能为空。如果表没有显式定义主键索引，MySQL会自动选择一个唯一且非空的列作为主键索引。设定为主键后数据库会自动建立索引，值必须唯一且不能为 null

### 3.3.4 组合索引（Composite Index）

> 组合索引是指在多个列上创建的索引。组合索引可以包含多个列，并且可以按照指定的列顺序进行查询。组合索引可以提高多列条件查询的性能，但需要根据实际查询需求和数据访问模式进行设计

### 3.3.5 哈希索引（Hash Index）

> 哈希索引使用哈希函数将索引列的值映射到一个哈希表中的位置。哈希索引适用于等值查询，可以快速定位到匹配的数据行。然而，哈希索引不支持范围查询和排序操作。哈希索引适用于等值查询，但不支持范围查询和排序操作。它使用哈希函数将索引值映射到索引桶中，通过哈希算法可以快速定位到特定的索引值

### 3.3.6 全文索引（Full-Text Index）

> 全文索引用于全文搜索，可以对文本数据进行关键字匹配。全文索引适用于在大量文本数据中进行关键字搜索的场景，例如文章内容或产品描述等。全文索引用于全文搜索，可以在文本数据中进行高效的关键词搜索。MySQL提供了全文索引的支持，可以用于对文本数据进行快速搜索

### 3.3.7 空间索引（Spatial Index）

> 空间索引用于存储和查询具有空间位置关系的数据，例如地理信息系统（GIS）中的地理位置数据。MySQL提供了空间索引的支持，可以进行空间位置相关的查询操作。空间索引用于处理空间数据类型（如地理坐标、地理位置等）的查询。空间索引可以加速对空间数据的空间关系查询，例如查找在某个区域内的点或计算距离等

## 3.4 索引结构

## 3.5 索引创建

### 3.5.1 建表时创建索引

使用 `INDEX` 或 `KEY` 关键字来指定创建索引，后面紧跟索引名和要创建索引的列名。

```sql
CREATE TABLE 表名 (
    列名 数据类型,
    ...
    [INDEX|KEY] 索引名 (列名),
    ...
);
```

### 3.5.2 单独创建索引

```sql
CREATE [UNIQUE] INDEX 索引名 ON 表名 (列名);
```

在上述语法中，可以使用 `CREATE INDEX` 或 `CREATE UNIQUE INDEX` 来创建索引，后面紧跟索引名、表名和要创建索引的列名。

### 3.5.3  ALTER TABLE 添加索引

```sql
ALTER TABLE 表名 ADD [UNIQUE] INDEX 索引名 (列名);
```

在上述语法中，可以使用 `ADD INDEX` 或 `ADD UNIQUE INDEX` 来添加索引，后面紧跟索引名、表名和要创建索引的列名。

需要注意的是，索引名是可选的，如果不指定索引名，MySQL 会自动生成一个默认的索引名。另外，对于唯一索引和主键索引，可以使用 `UNIQUE` 关键字来确保索引列的唯一性。

### 3.5.4 索引创建原则

1. 选择适当的列：选择需要经常用于查询条件的列来创建索引。通常，选择经常用于 WHERE 子句、JOIN 子句或 ORDER BY 子句的列作为索引列

2. 避免过多的索引：创建过多的索引可能会导致索引维护的开销增加，并且会占用额外的存储空间。只创建必要的索引来满足查询需求

3. 考虑索引的选择性：索引的选择性是指索引列中不同值的数量与总行数的比例。选择性较高的索引通常更有利于查询性能的提升

4. 考虑索引的大小和内存消耗：创建索引会占用额外的存储空间，并且需要加载到内存中进行查询。对于大型表和内存受限的系统，需要谨慎评估索引的大小和内存消耗

5. 组合索引的使用：对于经常同时使用多个列进行查询的情况，可以考虑创建组合索引。组合索引可以更好地支持多列的查询条件，并且可以减少索引的数量

6. 主键索引的选择：对于每个表，通常会选择一个主键来唯一标识每一行数据。主键索引可以提供快速的唯一性检查和数据访问。常见的主键选择包括自增 ID、UUID 或其他具有唯一性的列

7. 定期维护和优化索引：随着数据的变化和查询模式的调整，索引的效果可能会发生变化。定期进行索引的维护和优化，包括删除不再需要的索引、重新构建索引、重新评估索引的选择性等

## 3.6 索引优化

## 3.7 索引原理

### 3.7.1 B+ 树

MySQL 使用 B+ 树作为索引的底层数据结构，MySQL 索引的实现基于 B+ 树，每个索引对应一棵 B+ 树。在 B+ 树中，根节点存储了索引的元信息，包括树的高度、根节点指针等。内部节点存储了索引键和指向子节点的指针。叶子节点存储了索引键和对应的数据行指针。

1. 有序性：B+ 树中的节点按照键的大小顺序存储，保证了索引的有序性，便于范围查询和排序操作。

2. 平衡性：B+ 树通过自平衡的方式保持树的平衡，即每个叶子节点到根节点的路径长度相同，提高了查询效率。

3. 多层次：B+ 树是多层次的，从根节点到叶子节点有多个层级，每个层级上的节点数量相对较少，减少了磁盘 I/O 操作。

4. 叶子节点存储数据：B+ 树的叶子节点存储了完整的数据记录，而非仅存储索引键，这样可以减少磁盘 I/O 操作，提高查询性能。

5. 分裂和合并：当节点中的键值对数量超过一定阈值时，B+ 树会进行节点的分裂操作，将部分键值对移动到新的节点中；当节点中的键值对数量过少时，B+ 树会进行节点的合并操作，将相邻节点合并为一个节点。
   
   当进行查询时，MySQL 会根据查询条件从根节点开始，根据索引键的大小逐层搜索，直到找到叶子节点。如果是精确查询，直接找到对应的叶子节点即可获取数据行指针；如果是范围查询或排序操作，可以根据叶子节点的链表结构遍历获取满足条件的数据行。
   MySQL 的索引实现还包括一些优化技术，例如覆盖索引、索引下推和最左前缀匹配等。覆盖索引是指索引包含了查询所需的所有列，避免了对数据行的额外访问。索引下推是指将查询条件的过滤操作下推到存储引擎层进行，减少了不必要的数据行读取。最左前缀匹配是指在组合索引中，可以根据查询条件的最左边的列进行索引匹配，提高查询效率。通过合理设计和使用索引，可以提高 MySQL 数据库的查询性能和响应速度。但同时也需要注意索引的维护和更新成本，避免过度索引和不必要的索引。

B+树在数据库系统中的索引实现中起到关键作用。通过B+树的有序性和平衡性，可以快速定位到满足查询条件的叶子节点，并获取相应的数据。对于范围查询或排序操作，可以通过叶子节点的链表结构遍历获取满足条件的数据行。
在MySQL中，B+树的使用还涉及一些优化技术，例如覆盖索引、索引下推和最左前缀匹配等。覆盖索引是指索引包含了查询所需的所有列，避免了对数据行的额外访问。索引下推是指将查询条件的过滤操作下推到存储引擎层进行，减少了不必要的数据行读取。最左前缀匹配是指在组合索引中，可以根据查询条件的最左边的列进行索引匹配，提高查询效率。通过这些优化技术，可以进一步提高MySQL数据库的查询性能和响应速度。

1.B+ 树是基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。

2.在 B+ 树中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。

3.进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

4.插入、删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

### 3.7.2 聚簇索引（Clustered Index）

聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种[数据存储](https://cloud.tencent.com/product/cdcs?from_column=20065&from=20065)方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行

非聚簇索引：不是聚簇索引，就是非聚簇索引（认真脸）

聚簇索引是一种特殊类型的索引，它决定了数据在磁盘上的物理存储顺序。在聚簇索引中，数据行按照索引键的顺序进行排序，并且相邻的数据行物理上存储在一起，形成了一个数据页或数据块。
聚簇索引的主要特点如下：

1. **物理排序**：聚簇索引决定了数据在磁盘上的物理存储顺序，使得相邻的数据行存储在一起。这种物理排序可以提高范围查询、排序和顺序访问的性能。
2. **唯一性**：聚簇索引的键值必须是唯一的，因为它决定了数据行的物理存储位置。如果索引键不是唯一的，数据库系统通常会使用额外的标识符（如行标识符）来区分重复键的数据行。
3. **索引即数据**：在聚簇索引中，索引和数据存储在同一个结构中，因此查询时可以直接通过索引访问到所需的数据，无需进行额外的查找操作。
4. **一张表只能有一个聚簇索引**：每张表只能有一个聚簇索引，因为聚簇索引决定了数据行的物理存储顺序，而一张表只能按照一种顺序进行排序。
   聚簇索引在数据库系统中的使用具有一些优势和适用场景：
- 对于经常需要范围查询、排序或顺序访问的列，可以使用聚簇索引来提高查询性能和响应速度。
- 聚簇索引对于主键或唯一约束列非常适用，因为它们的值是唯一的，可以作为聚簇索引的键值。
- 当需要快速获取完整的数据行时，聚簇索引可以直接通过索引访问到所需的数据，无需进行额外的查找操作。
  需要注意的是，聚簇索引的使用也存在一些限制和考虑因素：
- 聚簇索引的建立和维护可能会引起数据行的移动和索引的重建成本，因此在频繁更新的表上使用聚簇索引需要谨慎权衡。
- 聚簇索引的键值必须是唯一的，因此在选择聚簇索引的列时需要考虑其唯一性。
- 聚簇索引的建立可能会导致表的大小增加，因为数据行需要按照索引键的顺序进行排序和存储。
  综上所述，聚簇索引是一种按照索引键的顺序对数据行进行物理排序的索引类型，可以提高范围查询、排序和顺序访问的性能。在数据库设计和优化中，合理选择和使用聚簇索引可以提高查询性能和响应速度，但需要根据具体的业务需求和数据特点进行权衡和优化。

在 MySQL 中，InnoDB 存储引擎使用 B+ 树作为索引的底层数据结构，并且默认情况下使用聚簇索引。
聚簇索引是一种特殊的索引方式，它决定了数据行在磁盘上的物理存储顺序与索引的顺序相同。在 InnoDB 中，每个表只能有一个聚簇索引，通常是主键索引。如果没有显式定义主键，InnoDB 会选择一个唯一的非空索引作为聚簇索引，如果都没有合适的索引，则会自动生成一个隐藏的聚簇索引。
聚簇索引的好处是可以将相关的数据行存储在物理上相邻的位置，从而提高查询性能。当根据聚簇索引进行查询时，InnoDB 可以通过索引的有序性快速定位到对应的数据行。此外，由于数据行的存储顺序与聚簇索引的顺序相同，当需要扫描聚簇索引时，可以避免不必要的磁盘 I/O 操作，提高查询效率。
在 B+ 树中，聚簇索引的叶子节点存储了完整的数据行，包括所有的列数据。这样的设计可以减少额外的数据行查找操作，提高查询性能。同时，如果需要更新数据行，由于聚簇索引的叶子节点存储了完整的数据行，可以直接在叶子节点上进行修改，而无需额外的查找和修改操作。
除了聚簇索引，InnoDB 还支持非聚簇索引（也称为辅助索引）。非聚簇索引的叶子节点存储了索引键和指向对应数据行的物理地址。当根据非聚簇索引进行查询时，InnoDB 首先根据索引键定位到对应的叶子节点，然后通过叶子节点中的物理地址获取完整的数据行。因此，在使用非聚簇索引进行查询时，需要进行两次磁盘访问，相比聚簇索引可能会有一定的性能损失。
总结起来，InnoDB 使用 B+ 树作为索引的底层数据结构，通过聚簇索引将数据行的物理存储顺序与索引的顺序相同，提高查询性能。同时，支持非聚簇索引来满足各种查询需求。

聚簇索引是一种数据存储方式，它实际上是在同一个结构中保存了B+树索引和数据行，InnoDB表是按照聚簇索引组织的（类似于Oracle的索引组织表）。

1. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键

2. 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新

3. 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据

二级索引的叶节点存储的是主键值，而不是行指针，这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间

# 4 事务

> 事务是将多个对数据库的操作作为单个逻辑工作单元处理的功能，目的是确保这组操作要么全部成功执行并提交（commit）永久保存，要么在发生错误时回滚（rollback）到事务开始前的状态，保持数据的一致性和完整性

## 4.1 事务分类

### 4.1.1 隐式事务（Implicit Transactions）

> 隐式事务是指在没有显式地使用事务语句（如 BEGIN、COMMIT、ROLLBACK）的情况下，MySQL 自动将每个 SQL 语句作为一个独立的事务进行处理。这意味着每个 SQL 语句都会自动成为一个事务，并根据其执行结果自动提交或回滚。

### 4.1.2 显式事务（Explicit Transactions）

> 显式事务是通过使用事务语句（如 BEGIN、COMMIT、ROLLBACK）来明确地定义事务的开始、提交和回滚。在显式事务中，您可以将一系列 SQL 语句组合成一个逻辑工作单元，并根据需要提交或回滚这个事务。

## 4.2 ACID特性

### 4.2.1 原子性（Atomicity）

> 原子性确保事务中的所有操作要么全部成功执行，要么全部回滚。如果事务中的任何操作失败，整个事务将被回滚到初始状态，不会对数据库造成任何改变。原子性保证了事务的一致性

### 4.2.2 一致性（Consistency）

> 一致性确保事务在执行前后数据库的状态保持一致。这意味着事务必须遵守预定义的规则和约束，以确保数据的完整性。如果事务执行成功，数据库将处于一致的状态；如果事务失败，数据库将回滚到事务开始前的一致状态

### 4.2.3 隔离性（Isolation）

> 隔离性指的是并发执行的多个事务之间应该相互隔离，互不干扰。每个事务应该感觉自己在独立地操作数据库，即使在同时运行的其他事务存在的情况下也是如此。隔离性可以防止并发事务之间的数据冲突和不一致

### 4.2.4 持久性（Durability）

> 持久性确保一旦事务提交成功，其所做的更改将永久保存在数据库中，即使在系统故障或崩溃后也是如此。持久性通过将事务的更改记录在持久存储介质（如磁盘）上来实现，以便在系统恢复后可以恢复数据

## 4.3 并发事务问题

当多个事务同时并发执行时，可能会出现一些并发事务问题，影响数据的一致性和可靠性

### 4.3.1 脏读（Dirty Read）

脏读是指一个事务读取到了另一个事务未提交的数据。如果一个事务读取到了另一个事务修改但尚未提交的数据，而后者最终回滚，那么前者读取到的数据就是无效的。脏读可能导致不正确的结果和数据的不一致

### 4.3.2 不可重复读（Non-repeatable Read）

不可重复读是指在同一个事务中，多次读取同一数据得到了不一致的结果。这是由于其他并发事务修改了数据并提交，导致事务多次读取同一数据时得到了不同的结果。不可重复读可能破坏事务的一致性

### 4.3.3幻读（Phantom Read）

幻读是指在同一个事务中，多次查询同一范围的数据时，得到了不同数量的数据行。这是由于其他并发事务在事务执行期间插入、更新或删除了符合查询条件的数据，导致事务多次查询同一范围的数据时得到了不同的结果。幻读可能破坏事务的一致性

### 4.3.4 更新丢失（Lost Update）

更新丢失是指两个事务同时读取同一数据，并且同时对该数据进行修改，但只有一个事务的修改被提交到数据库中，另一个事务的修改被覆盖丢失。这可能导致数据的不完整性和丢失

## 4.4 事务隔离级别

> 事务隔离级别是指数据库管理系统在处理并发事务时，对事务之间的隔离程度的控制。 MySQL 中默认的隔离级别是可重复读（Repeatable Read），可以使用 `SET TRANSACTION ISOLATION LEVEL` 语句来修改隔离级别

### 4.4.1 读未提交（Read Uncommitted）

> 最低的隔离级别，允许一个事务读取另一个事务尚未提交的未锁定数据。这可能导致脏读（读取到未提交的数据）和不可重复读（同一查询返回不同的结果）问题

### 4.4.2 读已提交（Read Committed）

> 一个事务只能读取已经提交的数据。但是，由于并发事务可能会修改数据，所以在同一事务中多次读取相同的数据可能会得到不一致的结果，这称为不可重复读问题

### 4.4.3 可重复读（Repeatable Read）

> 一个事务在执行期间多次读取同一数据将得到一致的结果。其他并发事务对该数据的修改只能在该事务提交后才可见。但是，这可能导致幻读问题，即在同一事务中多次查询同一范围的数据，结果集的行数可能不同

### 4.4.4 串行化（Serializable）

> 最高的隔离级别，确保每个事务都完全串行执行。它避免了脏读、不可重复读和幻读问题，但牺牲了并发性能

# 5 日志

> 日志用于记录数据库操作和状态变化

## 5.1 日志分类

### 5.1.1 二进制日志（Binary Log）

> 二进制日志以二进制格式存储，记录所有对数据库的修改操作，可以用于数据恢复、数据复制和数据库的主从同步。通过将二进制日志从主服务器复制到从服务器，可以实现数据的冗余备份和高可用性

### 5.1.2 事务日志（Transaction Log）

> 事务日志也称为回滚日志（Undo Log）或重做日志（Redo Log），记录正在进行的事务操作，包括对数据的修改和撤销操作。事务日志用于保证事务的持久性和一致性，以便在系统崩溃或故障时进行恢复

### 5.1.3 错误日志（Error Log）

> 错误日志记录 MySQL 服务器在运行过程中发生的错误和警告信息，可以帮助诊断和解决数据库运行中的问题，便于排查数据库故障和性能优化

### 5.1.4 查询日志（Query Log）

> 查询日志记录所有进入 MySQL 服务器的查询语句，也可以根据配置只记录特定类型或特定用户的查询，可以用于审计、性能分析和查询优化

### 5.1.5 慢查询日志（Slow Query Log）

> 慢查询日志记录了执行时间超过预设阈值的查询语句，可以用于分析和优化性能较差的查询，可以发现哪些查询需要进行优化，以提高数据库的响应时间和吞吐量

### 5.1.6 重复键日志（Duplicate Key Log）

> 重复键日志用于记录在使用唯一索引插入数据时发生的重复键错误，可以帮助识别和解决插入重复数据的问题

## 5.2 二进制日志（Binary Log）

二进制日志用于记录数据库的修改操作。它以二进制格式存储，并且可以用于数据恢复、数据复制和数据库的主从同步
**工作原理：**

1. 启用二进制日志：在 MySQL 配置文件中，需要设置 `log_bin` 参数为 `ON`，以启用二进制日志功能。默认情况下，二进制日志文件名为 `hostname-bin.index`，其中 `hostname` 是主机名。
2. 记录修改操作：当有对数据库的修改操作（如插入、更新、删除）时，MySQL 将这些操作以二进制格式记录到二进制日志文件中。每个操作都会被记录为一个日志事件（Log Event）。
3. 二进制日志格式：MySQL 提供了多种二进制日志格式，包括基于语句的复制（Statement-Based Replication，SBR）、基于行的复制（Row-Based Replication，RBR）和混合复制（Mixed-Based Replication，MBR）。这些格式决定了如何记录和重放修改操作。可以在配置文件中设置 `binlog_format` 参数来选择合适的日志格式。
4. 日志事件组成：每个日志事件包含了一个操作的详细信息，如操作类型、数据库、表名、修改前后的数据等。不同类型的操作会生成不同的日志事件。
5. 日志文件切换：当当前的二进制日志文件达到一定大小（由 `max_binlog_size` 参数设置）或一定时间（由 `expire_logs_days` 参数设置）时，MySQL 会自动切换到一个新的二进制日志文件，以便继续记录修改操作。
   **用途：**
6. 数据恢复：二进制日志可以用于恢复意外删除或修改的数据。通过将二进制日志应用到特定时间点之前的备份，可以将数据库恢复到指定的状态。
7. 数据复制和主从同步：通过将主服务器上的二进制日志复制到从服务器，可以实现数据库的复制和主从同步。从服务器可以重放主服务器上的二进制日志，以保持与主服务器的数据一致性。
8. 数据库迁移和升级：二进制日志可以用于将数据从一个 MySQL 实例迁移到另一个实例，或者在升级 MySQL 版本时进行数据迁移。通过将二进制日志应用到目标实例，可以保证数据的一致性和完整性。
9. 数据审计和故障排查：二进制日志记录了所有对数据库的修改操作，可以用于审计和追踪数据变更。它还可以用于故障排查，帮助确定特定时间段内的操作和事件。
   需要注意的是，二进制日志可能会占用较大的磁盘空间，并对数据库的性能产生一定的开销。因此，在配置二进制日志时需要考虑存储需求和性能要求。可以根据实际情况设置二进制日志的保留时间和大小限制，以及选择合适的二进制日志格式。
   此外，为了保证数据的一致性和完整性，应定期备份二进制日志，并将其存储在安全的位置。

## 5.3 回滚日志（Undo Log）

回滚日志是一种用于支持事务的重要组件，记录了在事务执行期间所做的修改操作，以便在需要回滚事务或者提供并发读取时进行恢复。回滚日志的主要功能是提供了撤销（undo）操作，用于将已提交的事务所做的修改操作回滚到事务开始之前的状态。这对于事务的隔离性和一致性非常重要。当事务需要回滚时，回滚日志中的信息可以用来撤销已经提交的修改，确保数据的完整性。回滚日志的实现方式通常是通过在内存中维护一个数据结构，称为回滚段（Rollback Segment）。回滚段包含了回滚日志的逻辑记录，每个记录都与一个事务相关联。回滚日志记录了事务所做的修改操作的细节，包括修改的数据页、修改前后的数据值等。当事务执行修改操作时，回滚日志会记录这些操作的逆操作，以便在回滚时可以撤销这些修改。当事务提交时，回滚日志中的相关信息可以被丢弃，因为这些修改已经永久生效。
回滚日志还有其他重要的用途。它可以支持并发读取，即在一个事务修改数据的同时，其他事务可以读取修改之前的数据。通过回滚日志，读取操作可以访问旧版本的数据，而不会受到正在进行的修改的影响。这种并发读取的能力提高了数据库的并发性能和并发控制的灵活性。此外，回滚日志还用于崩溃恢复。当数据库发生崩溃时，回滚日志可以用来恢复未完成的事务，确保数据库在恢复后的一致性。

## 5.4 重做日志（Redo Log）

重做日志是一种用于支持事务的关键组件。它记录了在事务执行期间所做的修改操作，以便在数据库崩溃或断电后进行恢复，确保数据的持久性和一致性。重做日志的主要功能是提供了重做（redo）操作，用于在崩溃恢复时重新执行已提交的事务所做的修改。当事务提交时，MySQL 不会立即将修改操作写入磁盘上的数据文件，而是先写入重做日志。这样可以提高事务的性能，因为将数据写入磁盘的操作通常比写入日志的操作更慢。重做日志的实现方式通常是通过在磁盘上维护一个循环写入的日志文件，称为重做日志文件（Redo Log File）。重做日志文件由多个固定大小的日志块组成，每个日志块都包含了一组事务的修改操作。当事务执行修改操作时，重做日志会记录这些操作的物理变化，包括修改的数据页、修改前后的数据值等。重做日志的记录是顺序写入的，这使得写入操作非常高效。在数据库崩溃或断电后，MySQL 会使用重做日志来进行崩溃恢复。通过重做日志，MySQL 可以重新执行已提交的事务所做的修改，将数据恢复到崩溃之前的状态。重做日志的记录是持久化的，即使数据库崩溃，重做日志文件也可以保留在磁盘上，以供恢复使用。重做日志还具有其他重要的作用。它可以支持数据库的持久性，即使在数据库崩溃或断电后，通过重做日志的恢复，数据也可以保持一致性。此外，重做日志还可以用于数据库的备份和复制，以及支持高可用性和故障转移。

# 6 约束

> MySQL 约束是一种用于确保数据库表中数据完整性和一致性的规则。它们定义了在表中插入、更新或删除数据时必须满足的条件

## 6.1 常见约束类型

### 6.1.1 列级约束

> 列级约束是直接应用于表的列上的约束规则，用于限制单个列的值

- 默认约束（Default Constraint）：默认约束是用于指定在插入新行时，如果未提供特定列的值，则将使用的默认值。它定义了列的默认值，以确保在插入新行时，如果未显式提供该列的值，则会自动使用默认值

- 主键约束（Primary Key Constraint）：主键是用于唯一标识表中每一行数据的列或列组合。主键约束确保主键值的唯一性和非空性。一个表只能有一个主键约束

- 唯一约束（Unique Constraint）：唯一约束确保在表中的指定列或列组合中的值是唯一的。与主键约束不同的是，唯一约束允许空值

- 非空约束（Not Null Constraint）：非空约束要求指定列中的值不能为空，即不允许插入或更新为空值

- 检查约束（Check Constraint）：检查约束定义了一个条件，该条件必须在插入或更新数据时满足。它可以是一个简单的逻辑表达式，用于限制列中的值的范围。

### 6.1.2 表级约束

> 表级约束是应用于整个表的约束规则，涉及到多个列或表之间的关系

1. 外键约束（Foreign Key Constraint）：外键约束用于建立表与表之间的关系。它定义了一个列或列组合，该列或列组合的值必须在另一个表的主键或唯一约束中存在。外键约束确保数据的引用完整性，即在引用表中的值必须在被引用表中存在

## 6.2 创建约束

### 6.2.1 创建默认约束

> 创建了名为`MyTable`的表，包含`ID`、和`Age`。`Age`列定义了一个默认约束，即默认值为18。当插入新行时，如果未显式提供`Age`列的值，则会自动使用默认值18

```sql
CREATE TABLE MyTable (
 ID INT,
 Age INT DEFAULT 18
);
```

### 6.2.2 创建主键约束

```sql
CREATE TABLE MyTable (
 ID INT PRIMARY KEY,
 Name VARCHAR(50)
);
```

上述示例创建了一个名为`MyTable`的表，其中包含`ID`和`Name`两列。`ID`列定义了一个主键约束，用于唯一标识表中的每一行数据。一个表只能有一个主键约束。

### 6.2.3 创建唯一约束

```sql
CREATE TABLE MyTable (
 ID INT,
 Email VARCHAR(50) UNIQUE,
 Name VARCHAR(50)
);
```

上述示例创建了一个名为`MyTable`的表，其中包含`ID`、`Email`和`Name`三列。`Email`列定义了一个唯一约束，确保在表中的`Email`列中的值是唯一的。唯一约束允许空值。

### 6.2.4 创建外键约束

```sql
CREATE TABLE Orders (
 OrderID INT PRIMARY KEY,
 ProductID INT,
 CustomerID INT,
 FOREIGN KEY (ProductID) REFERENCES Products(ProductID),
 FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);
```

上述示例创建了一个名为`Orders`的表，其中包含`OrderID`、`ProductID`和`CustomerID`三列。`ProductID`列和`CustomerID`列分别定义了外键约束，确保它们的值必须在另一个表的主键或唯一约束中存在。在上述示例中，`ProductID`列引用了`Products`表的`ProductID`列，`CustomerID`列引用了`Customers`表的`CustomerID`列。

### 6.2.5 创建非空约束

上述示例创建了一个名为`MyTable`的表，其中包含`ID`和`Name`两列。`Name`列定义了一个非空约束，要求该列中的值不能为空，即不允许插入或更新为空值

```sql
CREATE TABLE MyTable (
 ID INT,
 Name VARCHAR(50) NOT NULL
);
```

### 6.2.6 创建检查约束

> 上述示例创建了一个名为`MyTable`的表，其中包含`ID`和`Age`两列。`Age`列定义了一个检查约束，限制该列中的值必须大于等于18。检查约束定义了一个条件，该条件必须在插入或更新数据时满足

```sql
CREATE TABLE MyTable (
 ID INT,
 Age INT CHECK (Age >= 18)
);
```

## 6.3 删除约束

要删除约束，您需要使用`ALTER TABLE`语句，并指定要删除的约束类型和约束名称。以下是删除不同类型约束的示例：

### 6.3.1 删除默认约束

```sql
ALTER TABLE MyTable
ALTER COLUMN Age DROP DEFAULT;
```

上述示例从名为`MyTable`的表的`Age`列中删除了默认约束。

### 6.3.2 删除主键约束

```sql
ALTER TABLE MyTable
DROP CONSTRAINT PK_MyTable;
```

上述示例从名为`MyTable`的表中删除了名为`PK_MyTable`的主键约束。

### 6.3.3 删除唯一约束

```sql
ALTER TABLE MyTable
DROP CONSTRAINT UQ_MyTable_Email;
```

上述示例从名为`MyTable`的表中删除了名为`UQ_MyTable_Email`的唯一约束。

### 6.3.4 删除外键约束

```sql
ALTER TABLE Orders
DROP CONSTRAINT FK_Orders_Products;
```

上述示例从名为`Orders`的表中删除了名为`FK_Orders_Products`的外键约束。

### 6.3.5 删除非空约束

```sql
ALTER TABLE MyTable
ALTER COLUMN Name DROP NOT NULL;
```

上述示例从名为`MyTable`的表的`Name`列中删除了非空约束。

### 6.3.6删除检查约束

```sql
ALTER TABLE MyTable
DROP CONSTRAINT CHK_MyTable_Age;
```

上述示例从名为`MyTable`的表中删除了名为`CHK_MyTable_Age`的检查约束。
请注意，上述示例中的约束名称（如`PK_MyTable`、`UQ_MyTable_Email`等）是示例名称，您需要将其替换为实际约束的名称。使用适当的约束名称，您可以删除相应的约束。

## 6.4 修改约束

要修改约束，您需要使用`ALTER TABLE`语句，并指定要修改的约束类型和约束名称。以下是修改不同类型约束的示例：

### 6.4.1 修改默认约束

```sql
ALTER TABLE MyTable
ALTER COLUMN Age SET DEFAULT 0;
```

上述示例将名为`MyTable`的表的`Age`列的默认值修改为0。

### 6.4.2 修改主键约束

由于主键约束是用于唯一标识表中每一行数据的列或列组合，一般情况下不会修改主键约束。如果您需要修改主键约束，可能需要先删除原有的主键约束，然后再添加新的主键约束。

### 6.4.3 修改唯一约束

由于唯一约束确保在表中的指定列或列组合中的值是唯一的，一般情况下不会修改唯一约束。如果您需要修改唯一约束，可能需要先删除原有的唯一约束，然后再添加新的唯一约束。

### 6.4.4 修改外键约束

由于外键约束用于建立表与表之间的关系，一般情况下不会修改外键约束。如果您需要修改外键约束，可能需要先删除原有的外键约束，然后再添加新的外键约束。

### 6.4.5 修改非空约束

```sql
ALTER TABLE MyTable
ALTER COLUMN Name SET NOT NULL;
```

上述示例将名为`MyTable`的表的`Name`列修改为非空约束，即不允许插入或更新为空值。

### 6.6.6 修改检查约束

```sql
ALTER TABLE MyTable
DROP CONSTRAINT CHK_MyTable_Age;
ALTER TABLE MyTable
ADD CONSTRAINT CHK_MyTable_Age CHECK (Age >= 18);
```

上述示例首先删除名为`CHK_MyTable_Age`的检查约束，然后添加新的检查约束，要求`Age`列的值必须大于等于18。

# 7 数据类型、运算符、关键词、变量

## 7.1 基本数据类型

### 7.1.1 整数类型（Integer Types）

- `TINYINT`：1 字节，范围为 -128 到 127（有符号）或 0 到 255（无符号）

- `SMALLINT`：2 字节，范围为 -32,768 到 32,767（有符号）或 0 到 65,535（无符号）

- `MEDIUMINT`：3 字节，范围为 -8,388,608 到 8,388,607（有符号）或 0 到 16,777,215（无符号）

- `INT` 或 `INTEGER`：4 字节，范围为 -2,147,483,648 到 2,147,483,647（有符号）或 0 到 4,294,967,295（无符号）

- `BIGINT`：8 字节，范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（有符号）或 0 到 18,446,744,073,709,551,615（无符号）

### 7.1.2 浮点数类型（Floating-Point Types）

- `FLOAT`：4 字节，单精度浮点数
- `DOUBLE` 或 `REAL`：8 字节，双精度浮点数
- `DECIMAL` 或 `NUMERIC`：用于存储精确的小数值，需要指定精度和小数位数

### 7.1.3字符串类型（String Types）

- `CHAR`：固定长度字符串，最多 255 字节
- `VARCHAR`：可变长度字符串，最多 65,535 字节
- `TEXT`：可变长度文本字符串，最多 65,535 字节
- `ENUM`：枚举类型，存储从预定义值列表中选择的一个值
- `SET`：集合类型，存储从预定义值列表中选择的多个值

### 7.1.4 日期和时间类型（Date and Time Types）

- `DATE`：日期，格式为 'YYYY-MM-DD'
- `TIME`：时间，格式为 'HH:MM:SS'
- `DATETIME`：日期和时间，格式为 'YYYY-MM-DD HH:MM:SS'
- `TIMESTAMP`：时间戳，用于存储自动更新的日期和时间值
- `YEAR`：年份，范围为 1901 到 2155

### 7.1.5 布尔类型（Boolean Type）

- `BOOL` 或 `BOOLEAN`：存储布尔值，可以是 `TRUE` 或 `FALSE`

## 7.2 基本运算符

### 7.2.1 算术运算符（Arithmetic Operators）

- `+`：加法运算符，用于将两个值相加
- `-`：减法运算符，用于将一个值减去另一个值
- `*`：乘法运算符，用于将两个值相乘
- `/`：除法运算符，用于将一个值除以另一个值
- `%`：取模运算符，返回除法的余数

### 7.2.2 比较运算符（Comparison Operators）

- `=`：等于运算符，用于检查两个值是否相等
- `<>` 或 `!=`：不等于运算符，用于检查两个值是否不相等
- `>`：大于运算符，用于检查一个值是否大于另一个值
- `<`：小于运算符，用于检查一个值是否小于另一个值
- `>=`：大于等于运算符，用于检查一个值是否大于或等于另一个值
- `<=`：小于等于运算符，用于检查一个值是否小于或等于另一个值

### 7.2.3 逻辑运算符（Logical Operators）

- `AND` 或 `&&`：逻辑与运算符，用于将多个条件组合起来，要求所有条件都为真
- `OR` 或 `||`：逻辑或运算符，用于将多个条件组合起来，要求至少一个条件为真
- `NOT` 或 `!`：逻辑非运算符，用于取反一个条件的结果

### 7.2.4 字符串运算符（String Operators）

- `CONCAT()`：字符串连接运算符，用于将多个字符串连接成一个字符串
- `LIKE`：模糊匹配运算符，用于在查询中进行模糊匹配

### 7.2.5 空值判断运算符（Null Value Operators）

- `IS NULL`：用于检查一个值是否为 NULL

- `IS NOT NULL`：用于检查一个值是否不为 NULL

### 7.2.6 集合匹配运算符（Set Operators）

- `IN`：用于检查一个值是否存在于一个值列表中

- `NOT IN`：用于检查一个值是否不存在于一个值列表中

## 7.3 关键词

- `ALTER`：用于修改数据库表结构
- `ADD` : 用于在表中添加新的列
- `COLUMN`：用于定义表中的列
- `CREATE`：用于创建新的数据库表、视图、索引等对象
- `DATABASE`：用于创建和管理数据库
- `DELETE`：用于从数据库表中删除数据
- `DISTINCT`：用于返回唯一的查询结果
- `DROP`：用于删除数据库表、视图、索引等对象
- `FOREIGN KEY`：用于定义外键约束
- `GRANT`：用于授权用户访问数据库对象的权限
- `GROUP BY`：用于对查询结果进行分组
- `HAVING`
- `INDEX`：用于创建索引
- `INSERT`：用于将新数据插入到数据库表中
- `JOIN`：用于在多个表之间进行连接操作
- `LIMIT`：用于限制查询结果的数量
- `MODIFY` : 用于修改表中的列定义
- `NULL`：表示一个空值
- `ORDER BY`：用于对查询结果进行排序
- `PRIMARY KEY`：用于定义主键约束
- `REVOKE`：用于撤销用户对数据库对象的权限
- `SELECT`：用于从数据库中检索数据
- `TABLE`：用于创建和管理数据库表
- `UNION`：用于合并多个查询结果集
- `UPDATE`：用于更新数据库表中的数据
- `WHERE`：用于在查询中指定条件

## 7.4 变量

> 变量是用于存储和操作数据的命名值，可以在查询中使用，并且可以通过赋值和操作来改变其值

### 7.4.1 变量类型

#### 7.4.1.1 按作用域分类

1. 会话变量（Session Variables）：会话变量是在整个会话期间保持持久性的变量。它们在连接到MySQL服务器时创建，并且在断开连接之前一直存在。会话变量对于连接的所有查询都是可见的
2. 局部变量（Local Variables）：局部变量是在存储过程或函数中定义的变量。它们只在存储过程或函数的上下文中可见，并且在存储过程或函数执行完成后被销毁
3. 用户变量（User Variables）：用户变量是由用户在查询中定义的变量。它们以`@`符号开头，例如`@myVariable`。用户变量的作用域是会话级别的，即在连接期间保持持久性，但在会话结束后被销毁

#### 7.4.1.2 按数据类型分类

4. 数值型变量：用于存储数值数据，如整数、小数等
5. 字符型变量：用于存储字符串数据，如文本、字符等
6. 日期/时间型变量：用于存储日期和时间数据
7. 布尔型变量：用于存储布尔值（True或False）

### 7.4.2 变量创建与赋值

1. DECLARE语句创建局部变量
   
   ```sql
   DECLARE 
   variable_name datatype 
   [DEFAULT initial_value];
   ```

2. SET语句赋值变量
   
   ```sql
   SET variable_name = value;
   # 在使用SET语句赋值之前，变量必须已经存在或者已经通过DECLARE语句声明
   ```

3. SELECT语句将查询结果赋给变量
   
   ```sql
   SELECT column_name 
   INTO variable_name 
   FROM table_name 
   WHERE condition;
   ```

4. SELECT语句将单个值赋给变量
   
   ```sql
   SELECT 
   variable_name := column_name 
   FROM table_name 
   WHERE condition;
   ```

# 8 MySQL语法

## 8.1 数据定义语言

### 8.1.1 数据库操作

1. 创建数据库
   
   ```sql
   CREATE DATABASE mydatabase;
   ```

2. 查看当前数据库
   
   ```sql
   SELECT DATABASE();
   ```

3. 查看当前所有的数据库
   
   ```sql
   SHOW DATABASES;
   ```

4. 使用数据库
   
   ```sql
   USE mydatabase;
   ```

5. 删除数据库
   
   ```sql
   DROP DATABASE mydatabase;
   ```

### 8.1.2 表操作

1. 创建表
   
   ```sql
   CREATE TABLE mytable (
       id INT PRIMARY KEY,
       name VARCHAR(50),
       age INT
   );
   ```

2. 查看表结构
   
   ```sql
   DESCRIBE mytable;
   ```

3. 查看当前库的所有表
   
   ```sql
   SHOW TABLES;
   ```

4. 查看其他库的所有表
   
   ```sql
   SHOW TABLES FROM otherdatabase;
   ```

5. 修改表结构 - 添加列
   
   ```sql
   ALTER TABLE mytable
   ADD COLUMN email VARCHAR(100);
   ```

6. 复制表的结构
   
   ```sql
   CREATE TABLE new_table LIKE old_table;
   ```

7. 复制表的结构和数据
   
   ```sql
   CREATE TABLE new_table
   SELECT * FROM old_table;
   ```

8. 仅复制部分数据
   
   ```sql
   CREATE TABLE new_table
   SELECT id, au_name
   FROM old_table
   WHERE nation = '中国';
   ```

9. 仅复制某些字段
   
   ```sql
   CREATE TABLE new_table
   SELECT id, au_name
   FROM old_table
   WHERE 0;
   ```

10. 修改表结构 - 删除列
    
    ```sql
    ALTER TABLE mytable
    DROP COLUMN email;
    ```

11. 修改表结构 - 修改列数据类型
    
    ```sql
    ALTER TABLE mytable
    MODIFY COLUMN age BIGINT;
    ```

12. 修改表结构 - 修改列名
    
    ```sql
    ALTER TABLE mytable
    CHANGE COLUMN email new_email VARCHAR(100);
    ```

13. 删除表
    
    ```sql
    DROP TABLE mytable;
    ```

### 8.1.3 约束操作

1. 要创建主键
   
   ```sql
   ALTER TABLE mytable
   ADD PRIMARY KEY (id); # 在 mytable 表中创建名为 `id` 的主键
   ```

2. 创建外键
   
   ```sql
   ALTER TABLE orders # 在 orders 表中创建外键
   ADD FOREIGN KEY (customer_id) REFERENCES customers(id);
   # 外键引用 customers 表中的 id 列作为参考
   ```

3. 删除主键
   
   ```sql
   ALTER TABLE mytable
   DROP PRIMARY KEY;
   ```

4. 删除外键
   
   ```sql
   ALTER TABLE orders
   DROP FOREIGN KEY fk_name; # fk_name 是需要删除的外键名称
   ```

### 8.1.4 索引操作

1. 创建索引
   
   ```sql
   CREATE INDEX idx_name ON mytable (name);
   ```

2. 删除索引
   
   ```sql
   DROP INDEX idx_name ON mytable;
   ```

## 8.2 数据操作语言

1. 从数据库中查询数据
   
   ```sql
   SELECT * FROM customers;
   ```

2. 向数据库中插入新的数据
   
   ```sql
   INSERT INTO orders (order_number, customer_id, order_date)
   VALUES ('12345', 1, '2023-10-18');
   ```

3. 更新数据库中的数据
   
   ```sql
   UPDATE customers
   SET email = 'newemail@example.com'
   WHERE customer_id = 1;
   ```

4. 从数据库中删除数据
   
   ```sql
   DELETE FROM orders
   WHERE order_number = '12345';
   ```

## 8.3 数据控制语言

1. 授予用户或角色对数据库对象的访问权限
   
   ```sql
   GRANT SELECT, INSERT ON mytable TO user1;
   ```

2. 撤销用户或角色对数据库对象的访问权限
   
   ```sql
   REVOKE DELETE ON mytable FROM user2;
   ```

## 8.4 事务控制语言

> TCL用于管理数据库中的事务处理。它包括控制事务的提交和回滚操作，以及设置事务的隔离级别。常见的TCL语句包括：
> 
> - `COMMIT`：用于提交当前事务的操作
> - `ROLLBACK`：用于回滚当前事务的操作
> - `SAVEPOINT`：用于设置事务的保存点，以便在需要时回滚到保存点

## 8.5 常用函数

#### 8.5.1 字符函数

- `CONCAT`：拼接字符串
  
  ```sql
  SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;
  ```

- `SUBSTR`：截取子串
  
  ```sql
  SELECT SUBSTR(description, 1, 10) AS short_desc FROM products;
  ```

- `UPPER`：转换为大写
  
  ```sql
  SELECT UPPER(last_name) AS last_name_upper FROM users;
  ```

- `LOWER`：转换为小写
  
  ```sql
  SELECT LOWER(email) AS email_lower FROM users;
  ```

- `TRIM`：去除前后指定的空格和字符
  
  ```sql
  SELECT TRIM('  abc  ') AS trimmed_string;
  ```

- `LPAD`：左填充
  
  ```sql
  SELECT LPAD('123', 5, '0') AS padded_string;
  ```

- `RPAD`：右填充
  
  ```sql
  SELECT RPAD('123', 5, '0') AS padded_string;
  ```

- `REPLACE`：替换字符串
  
  ```sql
  SELECT REPLACE('Hello, World!', 'World', 'OpenAI') AS replaced_string;
  ```

- `LENGTH`：获取字节个数
  
  ```sql
  SELECT LENGTH('Hello') AS string_length;
  ```

#### 8.5.2 数学函数

- `ROUND`：四舍五入
  
  ```sql
  SELECT ROUND(3.14159, 2) AS rounded_number;
  ```

- `RAND`：生成随机数
  
  ```sql
  SELECT RAND() AS random_number;
  ```

- `FLOOR`：向下取整
  
  ```sql
  SELECT FLOOR(3.8) AS rounded_down_number;
  ```

- `CEIL`：向上取整
  
  ```sql
  SELECT CEIL(3.2) AS rounded_up_number; # 将3.2向上取整，结果为 4
  ```

- `MOD`：取余
  
  ```sql
  SELECT MOD(10, 3) AS remainder;
  ```

- `TRUNCATE`：截断小数部分
  
  ```sql
  SELECT TRUNCATE(3.14159, 2) AS truncated_number; # 结果为 3.14
  ```

#### 8.5.3 日期函数

- `NOW`：获取当前系统日期和时间
  
  ```sql
  SELECT NOW() AS current_datetime; # 返回当前系统的日期和时间
  ```

- `CURDATE`：获取当前系统日期
  
  ```sql
  SELECT CURDATE() AS current_date; # 返回当前系统的日期
  ```

- `CURTIME`：获取当前系统时间
  
  ```sql
  SELECT CURTIME() AS current_time; # 返回当前系统的时间
  ```

- `STR_TO_DATE`：将字符串转换为日期
  
  ```sql
  SELECT STR_TO_DATE('2023-10-18', '%Y-%m-%d') AS converted_date;
  ```
  
  这将将字符串 `'2023-10-18'` 转换为日期格式，使用的格式字符串为 `%Y-%m-%d`。

- `DATE_FORMAT`：将日期转换为字符串
  
  ```sql
  SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') AS formatted_datetime;
  ```
  
  这将将当前日期和时间格式化为字符串，使用的格式字符串为 `%Y-%m-%d %H:%i:%s`。

#### 8.5.4 流程控制函数

- `IF`：处理双分支条件
  
  ```sql
  SELECT IF(score >= 60, 'Pass', 'Fail') AS result FROM students;
  ```
  
  这将从 `students` 表中选择 `score` 字段，并根据分数是否大于等于 60 来返回 `'Pass'` 或 `'Fail'`

- `IFNULL(expression, alt_value) `如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值(此题中是返回null)。 expression是table的时候要加括号

- `CASE`：处理多分支条件
  
  - 处理等值判断：
    
    ```sql
    SELECT
      CASE grade
        WHEN 'A' THEN 'Excellent'
        WHEN 'B' THEN 'Good'
        WHEN 'C' THEN 'Average'
        ELSE 'Fail'
      END AS result
    FROM students;
    ```
    
    这将从 `students` 表中选择 `grade` 字段，并根据不同的等级返回相应的结果。
  
  - 处理条件判断：
    
    ```sql
    SELECT
      CASE
        WHEN score >= 90 THEN 'A'
        WHEN score >= 80 THEN 'B'
        WHEN score >= 70 THEN 'C'
        ELSE 'D'
      END AS grade
    FROM students;
    ```
    
    这将从 `students` 表中选择 `score` 字段，并根据不同的分数范围返回相应的等级。

#### 8.5.5 聚合函数

- `SUM`：求和
  
  ```sql
  SELECT SUM(sales) AS total_sales FROM orders;
  ```

- `MAX`：最大值
  
  ```sql
  SELECT MAX(price) AS max_price FROM products;
  ```

- `MIN`：最小值
  
  ```sql
  SELECT MIN(quantity) AS min_quantity FROM inventory;
  ```

- `AVG`：平均值
  
  ```sql
  SELECT AVG(score) AS average_score FROM students;
  ```

- `COUNT`：计数
  
  ```sql
  SELECT COUNT(*) AS total_records FROM customers;
  ```

- `GROUP_CONCAT` ：将多行数据中的某个列的值连接成一个字符串，并以逗号（默认分隔符）分隔各个值
  
  ```sql
  GROUP_CONCAT([DISTINCT] expression [ORDER BY clause] [SEPARATOR separator])
  ```
  
  - `DISTINCT`（可选）：用于去除重复的值。当指定 `DISTINCT` 关键字时，只有唯一的值会被连接到结果字符串中
  - `expression`：要连接的列或表达式。可以是列名、表达式、常量或函数的结果
  - `ORDER BY clause`（可选）：用于指定连接结果的排序顺序。可以是列名或表达式
  - `SEPARATOR separator`（可选）：用于指定连接结果中各个值的分隔符，默认为逗号（`,`）

# 9 数据库基本操作

## 9.1 多表查询

> 多表查询是指在一个查询语句中涉及到多个表的查询操作。多表查询可以通过连接（JOIN）操作将多个表关联起来，并根据关联条件进行数据的匹配和筛选，从而得到所需的结果

### 9.1.1 内连接（INNER JOIN）

> 内连接根据两个表之间的关联条件，返回两个表中满足条件的交集。内连接可以使用`JOIN`关键字来实现，也可以使用`INNER JOIN`关键字来明确表示内连接

```sql
SELECT *
FROM table1
JOIN table2 ON table1.id = table2.id;
```

### 9.1.2 左外连接（LEFT OUTER JOIN）

> 左连接返回左表中所有的记录，以及右表中与左表满足关联条件的记录，按照ON后的关联条件匹配右表。如果右表中没有匹配的记录，将返回NULL值。左连接可以使用`LEFT JOIN`关键字来实现

```sql
SELECT *
FROM table1
LEFT JOIN table2 ON table1.id = table2.id;
```

### 9.1.3 右外连接（LEFT OUTER JOIN）

> 右连接返回右表中所有的记录，以及左表中与右表满足关联条件的记录。如果左表中没有匹配的记录，将返回NULL值。右连接可以使用`RIGHT JOIN`关键字来实现

```sql
SELECT *
FROM table1
RIGHT JOIN table2 ON table1.id = table2.id;
```

### 9.1.4 全连接（FULL JOIN）

> 全连接返回左表和右表中所有的记录，无论是否满足关联条件。如果某个表中没有匹配的记录，将返回NULL值。MySQL并不直接支持全连接，但可以通过左连接和右连接的组合来模拟实现

```sql
SELECT *
FROM table1
LEFT JOIN table2 ON table1.id = table2.id
UNION
SELECT *
FROM table1
RIGHT JOIN table2 ON table1.id = table2.id;
```

### 9.1.5 子查询（Subquery）

> 子查询是指在一个查询语句中嵌套使用另一个查询语句。可以将子查询的结果作为条件或数据源来进行多表查询

```sql
SELECT *
FROM table1
WHERE table1.id IN (SELECT id FROM table2);
```

### 9.1.6 聚合函数和分组（GROUP BY）

在多表查询中，可以使用聚合函数（如SUM、AVG、COUNT等）对多个表的数据进行统计和计算。同时，可以使用`GROUP BY`子句对查询结果进行分组，以得到按照某个字段进行分组的汇总数据。
以上是MySQL多表查询的一些基本操作和技巧。通过合理使用连接操作、子查询、聚合函数和分组等功能，可以实现复杂的数据查询和分析需求。

- 等值连接：ON A.id=B.id
- 不等值连接：ON A.id > B.id
- 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid 

### 9.1.7 联合查询（UNION / UNION ALL）

```
SELECT * FROM A UNION SELECT * FROM B UNION ...
```

- 就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并
- 如果使用UNION ALL，不会合并重复的记录行
- 效率 UNION 高于 UNION ALL

## 9.2 储存过程（Stored Procedure）

> MySQL中的存储过程是一组预编译的SQL语句集合，它们被存储在数据库中，并可以在需要时被调用执行。存储过程允许开发人员将常用的操作逻辑封装在数据库中，以提高代码的可重用性和执行效率
> 
> 储存过程是一组预定义的SQL语句集合，它们被命名并存储在数据库中，可以通过名称调用和执行。储存过程可以接受参数，并且可以包含条件逻辑、循环和异常处理。储存过程通常用于执行复杂的数据库操作，提高数据库的性能和安全性。

### 9.2.1 储存过程优缺点

> 1. 提高性能：储存过程在数据库服务器上进行预编译，可以减少网络传输的开销。一旦储存过程被编译，执行相同的操作时会更快，因为不需要再次解析和编译SQL语句
> 
> 2. 提高安全性：储存过程可以设置访问权限，只允许特定用户或角色执行。这样可以控制对数据库的访问，并提供更好的安全性
> 
> 3. 降低数据传输量：通过使用储存过程，可以将复杂的业务逻辑移到数据库层面，减少了需要传输的数据量。只需将必要的结果返回给客户端，而不是传输大量的数据
> 
> 4. 代码复用和维护：储存过程可以在多个应用程序中重复使用，提高了代码的复用性。它们也可以被集中管理和维护，使得对数据库逻辑的更改更加方便和一致
> 
> 5. 事务控制：储存过程可以作为一个事务单元，允许多个SQL语句在一个原子操作中执行。这样可以确保数据的一致性和完整性，避免了并发操作导致的数据问题

> 学习和开发成本：储存过程需要使用特定的语法和编程技巧，对于开发人员来说可能需要额外的学习成本。编写和调试复杂的储存过程可能比直接编写应用程序代码更困难
> 
> 依赖于数据库平台：储存过程的语法和功能在不同的数据库平台上可能有所不同。如果需要将应用程序迁移到另一个数据库平台，可能需要重写储存过程
> 
> 可维护性和版本控制：由于储存过程存储在数据库中，对于版本控制和协同开发可能会带来一些挑战。更改储存过程可能需要对数据库进行迁移和更新，需要谨慎管理
> 
> 可扩展性限制：储存过程在某些情况下可能会限制应用程序的可扩展性。如果大量的业务逻辑被放在储存过程中，可能会导致数据库层面的性能瓶颈，难以进行水平扩展
> 综上所述，储存过程在提高性能、安全性和代码复用方面具有优势，但也存在学习成本、平台依赖性和可维护性等方面的考虑。在使用储存过程时，需要权衡这些优缺点，并根据具体的业务需求和数据库架构来做出决策

### 9.2.2 储存过程创建、删除

## 9.3 储存函数（Stored Functions）

> 储存函数类似于储存过程，也是一组预定义的SQL语句集合，但它们返回一个值。储存函数可以像内置函数一样在SQL查询中使用，并且可以接受参数。储存函数通常用于计算、转换或处理数据，并将结果返回给调用者

### 9.3.1 储存函数优缺点

### 9.3.2 储存函数创建、删除

## 9.4 视图（Views）

> 视图是虚拟的表，它是基于一个或多个数据库表的查询结果。视图可以像表一样被查询，但实际上它并不存储任何数据。视图提供了一种简化和重用查询的方式，可以隐藏复杂的查询逻辑，并提供更简洁的数据访问接口。视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。只暴露部分字段给访问者，所以就建一个虚表，就是视图。查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

## 9.5 触发器（Triggers）

触发器是与表相关联的特殊类型的数据库对象，它在特定的数据库操作（如插入、更新或删除）发生时自动触发执行一系列的SQL语句

### 触发器类型

MySQL支持两种类型的触发器：`BEFORE`触发器和`AFTER`触发器。`BEFORE`触发器在触发事件之前执行，而`AFTER`触发器在触发事件之后执行。

**触发事件**：触发器与特定的数据库事件相关联，包括`INSERT`（插入操作）、`UPDATE`（更新操作）和`DELETE`（删除操作）。

**触发条件**：可以为触发器定义触发条件，只有当满足特定的条件时才会触发触发器的执行。触发条件是基于触发事件中的旧值（`OLD`）和新值（`NEW`）进行判断。

**触发器动作**：触发器的执行体是一系列的SQL语句，可以包括数据操作语句（如插入、更新、删除）、查询语句或其他数据库操作。

**触发器的创建和管理**：使用`CREATE TRIGGER`语句创建触发器，并指定触发器的名称、触发事件、触发条件和触发动作。使用`DROP TRIGGER`语句删除触发器。
触发器可以在数据库中实现复杂的业务逻辑、强制数据完整性约束以及记录数据变化等操作。通过触发器，可以在特定的数据库事件发生时自动执行预定义的操作，减少手动操作和确保数据的一致性。

## 9.6 函数（Functions）

> 函数是一段可重用的代码，接受输入参数并返回一个值。在MySQL中，有内置函数（如数学函数、字符串函数等）和用户自定义函数两种类型。用户自定义函数是根据特定需求编写的自定义代码，可以在SQL查询中使用，类似于储存函数。这些数据库对象（储存过程、储存函数、视图和函数）提供了更高级的数据处理和访问方式，可以根据具体需求选择合适的方式来使用。它们可以帮助简化复杂的操作、提高数据库性能和代码重用性。

# MySQL复制

**1、主：** binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；

**2、从：** io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；

**3、从：** sql执行线程——执行relay log中的语句；

### 主从复制中涉及到哪三个线程？

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

1.binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。

2.I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log） 中。

3.SQL 线程 ：负责读取重放日志并重放其中的 SQL 语句。

# MySQL优化

## SQL 优化

- **1、** 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
- **2、** 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

```
select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=
```

- **3、** 应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描
- **4、** 应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描

```
select id from t where num=10 or num=20可以这样查询：select id from t where num=10 union all select id from t where num=20
```

- **5、** in 和 not in 也要慎用，否则会导致全表扫描

```
select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3
```

- **6、** 下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索
- **7、** 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描

```
select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num
```

- **8、** 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：

```
select id from t where num/2=100应改为:select id from t where num=100*2
```

- **9、** 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：

```
select id from t where substring(name,1,3)=’abc’ ，name以abc开头的id应改为:select id from t where name like ‘abc%’
```

- **10、** 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

### 如何优化SQL

**1、SQL语句中IN包含的值不应过多**

MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：`select id from table_name where num in(1,2,3)` 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。

**2、SELECT语句务必指明字段名称**

SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。

**3、当只需要一条数据的时候，使用limit 1**

这是为了使EXPLAIN中type列达到const类型

**4、如果排序字段没有用到索引，就尽量少排序**

**5、如果限制条件中其他字段没有索引，尽量少用or**

or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果

**6、尽量用union all代替union**

union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。**当然，union all的前提条件是两个结果集没有重复数据。**

**7、不使用ORDER BY RAND()**

```sql
select id from `table_name` order by rand() limit 1000;
```

上面的sql语句，可优化为

```sql
select id from `table_name` t1 join (select rand() * (select max(id) from `table_name`) as nid) t2 ont1.id > t2.nid limit 1000;
```

**8、区分in和exists， not in和not exists**

```sql
select * from 表A where id in (select id from 表B)
```

上面sql语句相当于

```sql
select * from 表A where exists(select * from 表B where 表B.id=表A.id)
```

区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以**IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。** 关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。**如何高效的写出一个替代not exists的sql语句？**

原sql语句

```sql
select colname … from A表 where a.id not in (select b.id from B表)
```

高效的sql语句

```csharp
select colname … from A表 Left join B表 on where a.id = b.id where b.id is null
```

取出的结果集如下图表示，A表不在B表中的数据

**9、使用合理的分页方式以提高分页的效率**

```sql
select id,name from table_name limit 866613, 20
```

使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。

优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：

```csharp
select id,name from table_name where id> 866612 limit 20
```

**10、分段查询**

在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。

如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询

**11、避免在 where 子句中对字段进行 null 值判断**

对于null的判断会导致引擎放弃使用索引而进行全表扫描。

**12、不建议使用%前缀模糊查询**

例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。

**那如何查询%name%？**

如下图所示，虽然给secret字段添加了索引，但在explain结果果并没有使用

那么如何解决这个问题呢，答案：**使用全文索引**

在我们查询中经常会用到select id,fnum,fdst from table_name where user_name like '%zhangsan%'; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。

创建全文索引的sql语法是：

```go
ALTER TABLE `table_name` ADD FULLTEXT INDEX `idx_user_name` (`user_name`);
```

使用全文索引的sql语句是：

```csharp
select id,fnum,fdst from table_name where match(user_name) against('zhangsan' in boolean mode);
```

**注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别**

**13、避免在where子句中对字段进行表达式操作**

比如

```csharp
select user_id,user_project from table_name where age*2=36;
```

中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成

```csharp
select user_id,user_project from table_name where age=36/2;
```

**14、避免隐式类型转换**

where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型

**15、对于联合索引来说，要遵守最左前缀法则**

举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面

**16、必要时可以使用force index来强制查询走某个索引**

有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。

**17、注意范围查询语句**

对于联合索引来说，如果存在范围查询，比如between,>,<等条件时，会造成后面的索引字段失效。

**18、关于JOIN优化**

- LEFT JOIN A表为驱动表
- INNER JOIN MySQL会自动找出那个数据少的表作用驱动表
- RIGHT JOIN B表为驱动表

**注意：MySQL中没有full join，可以用以下方式来解决**

```csharp
select * from A left join B on B.name = A.name 
where B.name is null
 union all
select * from B;
```

**尽量使用inner join，避免left join**

参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。

**合理利用索引**

被驱动表的索引字段作为on的限制字段。

**利用小表去驱动大表**

从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。

**巧用STRAIGHT_JOIN**

inner join是由mysql选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。**在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。**

这个方式有时可能减少3倍的时间。

## 数据库优化

**1、** 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL， 例如’ 省份’、’ 性别’ 最好适用 ENUM

**2、** 使用连接(JOIN)来代替子查询

**3、** 适用联合(UNION)来代替手动创建的临时表

**4、** 事务处理

**5、** 锁定表、优化事务处理

**6、** 适用外键， 优化锁定表

**7、** 建立索引

**8、** 优化查询语句 

### 横向分表和纵向分表、分区、分库

**横向分表是按行分表.**

假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.

**纵向分表是按列分表.**

假设我们现在有一张文章表.包含字段`id-摘要-内容`.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.`id-摘要`,`id-内容`.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.

当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.

### SQL 注入

**SQL 注入产生的原因：** 程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。防止 SQL 注入的方式：

开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置

执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 语句书写尽量不要省略双引号和单引号。

过滤掉 sql 语句中的一些关键词： update、insert、delete、select、 * 。

提高数据库表和字段的命名技巧， 对一些重要的字段根据程序的特点命名， 取不易被猜到的。

# 锁

### 锁的分类

**1、表级锁：** 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。

**2、行级锁：** 开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。

**3、页面锁：** 开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。

## 乐观锁和悲观锁

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

**悲观锁：** 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 

**乐观锁：** 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

### 锁机制与InnoDB锁算法

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

**表级锁和行级锁对比：**

- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB存储引擎的锁的算法有三种：**

- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 锁定一个范围，包含记录本身

从锁的类别上来讲,有共享锁和排他锁.

**共享锁:** 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.

**排他锁:** 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.

用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.

锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.

他们的加锁开销从大大小,并发能力也是从大到小.

### 锁的优化策略

**1、** 读写分离

**2、** 分段加锁

**3、** 减少锁持有的时间

多个线程尽量以相同的顺序去获取资源

不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如一次加一把大锁。

锁是一种并发控制技术,锁是用来在多个用户同时访问同一个数据的时候 保护数据的 。

产生死锁的四个必要条件:

(1) 互斥条件:一个资源每次只能被一个进程使用。 
(2) 请求与保持条件:一个进程因请求资源而阻塞时,对已获得的资源保持不放。 
(3) 不可剥夺条件:进程已获得的资源,在末使用完之前,不能强行剥夺。 
(4) 环路等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

##### 预防死锁

     预防死锁的发生只需破坏死锁产生的四个必要条件之一即可。

##### 避免死锁

     银行家算法。

### 22. mysql 锁的粒度(即锁的级别)

1. 表级锁,直接锁定整张表,在你锁定期间,其它进程无法对该表进行写操作。
2. 行级锁,仅对指定的记录进行加锁,这样其它进程还是可以对同一个表中的其它记 录进行操作。
3. 页级锁,一次锁定相邻的一组记录 

# 常见问题

### HAVING和WHERE

WHERE子句：WHERE子句用于在查询之前对行数据进行过滤。它可以在SELECT语句中使用，也可以在UPDATE、DELETE等语句中使用。WHERE子句基于行级别的条件进行过滤，可以使用各种比较运算符（如=、<、>、<>等）和逻辑运算符（如AND、OR、NOT）来指定条件。WHERE子句可以过滤出满足条件的行数据，然后再进行其他操作

```sql
SELECT column1, column2, ...
FROM table
WHERE condition;
```

HAVING子句：HAVING子句用于在GROUP BY子句之后对分组后的数据进行过滤。它只能在SELECT语句中使用，并且用于对分组后的结果进行条件过滤。HAVING子句基于聚合函数的结果进行过滤，可以使用聚合函数和其他比较运算符来指定条件。HAVING子句用于过滤出满足条件的分组结果

```sql
SELECT column1, column2, ...
FROM table
GROUP BY column1, column2, ...
HAVING condition;
```

总结：

- WHERE子句用于在查询之前对行数据进行过滤。

- HAVING子句用于在GROUP BY子句之后对分组后的数据进行过滤。
  需要注意的是，WHERE子句在执行查询之前进行过滤，而HAVING子句在分组之后进行过滤。因此，如果您只是需要过滤行数据而不涉及分组，应该使用WHERE子句。如果您需要对分组结果进行过滤，应该使用HAVING子句。

### 如何锁定一行？

### 最左前缀原则

如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。

### 怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?

使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possilbe_key、key、key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。

### 什么情况下索引会失效？即查询不走索引？

1.索引列参与表达式计算：

SELECT 'sname' FROM 'stu' WHERE 'age' + 10 = 30;

2.函数运算：

SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) < 1990;

3.%词语%--模糊查询：

SELECT * FROM 'manong' WHERE `uname` LIKE '码农%' -- 走索引
SELECT * FROM 'manong' WHERE `uname` LIKE "%码农%" -- 不走索引

4.字符串与数字比较不走索引：

CREATE TABLE 'a' ('a' char(10)); EXPLAIN SELECT * FROM 'a' WHERE 'a'="1" -- 走索引

EXPLAIN SELECT * FROM 'a'WHERE 'a'=1 **-- 不走索引，同样也是使用了函数运算**

5.查询条件中有 or ，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引：

select * from dept where dname='xxx' or loc='xx' or deptno = 45;

6.正则表达式不使用索引。

7.MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。

8.is null,is not null 也无法使用索引

### 主从同步的延迟原因及解决办法？

#### 主从同步的延迟的原因：

假如一个服务器开放 Ｎ 个连接给客户端，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个， 当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL 要进行锁表就会导致主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。

#### 主从同步延迟的解决办法：

实际上主从同步延迟根本没有什么一招制敌的办法， 因为所有的 SQL 必须都要在从服务器里面执行一遍，但是主服务器如果不断的有更新操作源源不断的写入，那么一旦有延迟产生，那么延迟加重的可能性就会原来越大。当然我们可以做一些缓解的措施。

1.我们知道因为主服务器要负责更新操作， 它对安全性的要求比从服务器高，所有有些设置可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而 slave 则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭 binlog、innodb_flushlog、innodb_flush_log_at_trx_commit 也 可以设置为 0 来提高 SQL 的执行效率。
2.增加从服务器，这个目的还是分散读的压力， 从而降低服务器负载。

### 40、谈谈你对数据库读写分离的理解？

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

##### 读写分离能提高性能的原因在于：

1.主从服务器负责各自的读和写，极大程度缓解了锁的争用；

2.从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；

3.增加冗余，提高可用性。

### 41、 MVCC

数据库并发场景：

1.读-读：不存在任何问题，也不需要并发控制；

2.读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；

3.写-写：有线程安全问题，可能会存在更新丢失问题。

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事 务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读 操作只读该事务开始前的数据库的快照。

##### MVCC 可以为数据库解决以下问题

1.在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；

2.同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。

### 43、InnoDB 存储引擎的锁的算法有哪些？

1.Record lock：单个行记录上的锁；

2.Gap lock：间隙锁，锁定一个范围，不包括记录本身；

3.Next-key lock：record+gap 锁定一个范围，包含记录本身。

### 44、MySQL 问题排查都有哪些手段？

##### 1.开启慢查询日志，查看慢查询的 SQL。

运用日志分析工具mysqldumpslow，命令：

##### 2.再根据出现问题的sql语句，使用 Explain 命令查询 SQL 语句执行计划

命令：Explain+SQL语句 
主要查看type字段： 
显示查询使用了何种类型 
从最好到最差依次是：

system>const>eq_ref>ref>range>index>ALL

ey字段： 
实际使用的索引。如果为null则没有使用索引 
查询中若使用了覆盖索引，则索引和查询的select字段重叠

SELECT CURRENT_DATE();

### Explain 性能分析

查看执行计划：使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。分析查询语句或是表结构的性能瓶颈。

**能干嘛**

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询

**怎么玩**

Explain + SQL 语句。
Explain 执行后返回的信息：

**各字段解释**

1. id：select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序。
   
   - id 相同，执行顺序由上至下
   - id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行
   - id 有相同也有不同：id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行
   
   > id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。

2. select_type：代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询，取值范围如下：
   
   - simple：简单的 select 查询，查询中不包含子查询或者 UNION
   - primary：查询中若包含任何复杂的子部分，最外层查询则被标记为 primary
   - derived：在 FROM 列表中包含的子查询被标记为 DERIVED (衍生)，MySQL 会递归执行这些子查询, 把结果放在临时表里。
   - subquery：在 SELECT 或 WHERE 列表中包含了子查询
   - depedent subquery：在 SELECT 或 WHERE 列表中包含了子查询，子查询基于外层
   - uncacheable subquery：无法使用缓存的子查询
   - union：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED
   - union result：从 UNION 表获取结果的 SELECT

3. table：这个数据是基于哪张表的。

4. type：是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。
   
   > 只需要记住：system > const > eq_ref > ref > range > index > ALL 就行了，其他的不常见。
   
   - system：表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计。
   - const：表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。
   - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
   - ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
   - range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引一般就是在 where 语句中出现了 between、<、>、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。
   - index：出现 index 是 sql 使用了索引但是没用索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。
   - all：将遍历全表以找到匹配的行。
   
   > 其他 type 如下：
   
   - index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 关键字的 sql 中。
   - ref_or_null：对于某个字段既需要过滤条件，也需要 null 值的情况下。查询优化器会选择用 ref_or_null 连接查询。
   - index_subquery：利用索引来关联子查询，不再全表扫描。
   - unique_subquery：该联接类型类似于 index_subquery。子查询中的唯一索引。

5. possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。

6. key：实际使用的索引。如果为 NULL，则没有使用索引。

7. key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度。如何计算 key_len？
   
   - 先看索引上字段的类型 + 长度，比如：int=4; varchar(20)=20; char(20)=20
   - 如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3，GBK 要乘 2
   - varchar 这种动态字符串要加 2 个字节
   - 允许为空的字段要加 1 个字节

8. ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。

9. rows：显示 MySQL 认为它执行查询时必须检查的行数。越少越好！

10. Extra：其他的额外重要的信息。
    
    - Using filesort：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。**排序字段若通过索引去访问将大大提高排序速度**。
    - Using temporary：使用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。
    - Using index：表示相应的 select 操作中使用了覆盖索引 (Covering Index)，避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。
    - Using where：表明使用了 where 过滤。
    - Using join buffer：使用了连接缓存。
    - impossible where：where 子句的值总是 false，不能用来获取任何数据。
    - select tables optimized away：在没有 group by 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。
    - distinct：优化 distinct 操作，在找到第一匹配的元祖后即停止找同样值的动作。

##### 3.使用Show profiles

### varchar(10)和int(10)代表什么含义?

varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.

### varchar 和 text 的区别

- varchar可指定字符数，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n<=255）或2个字节(n>255)，text是实际字符数+2个字节。
- text类型不能有默认值。
- varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引几乎不起作用。
- 查询text需要创建临时表。

### FLOAT和DOUBLE的区别是什么？

- FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。
- DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。

### MySQL数据库cpu飙升到500%的话他怎么处理？

**1、** 列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)

**2、** 查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)

### 超大分页处理

超大的分页一般从两个方向上来解决.

- 数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于`select * from table where age > 20 limit 1000000,10`这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为`select * from table where id in (select id from table where age > 20 limit 1000000,10)`.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以`select * from table where id > 1000000 limit 10`,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.
  
  - 从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.
    
    解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.
    
    在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.
    
    ### 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?
    
    在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.
    
    慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?
    
    所以优化也是针对这三个方向来的,
    
    - 首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.
      - 分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.
      - 如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.
  
  ###如果一个表有一列定义为TIMESTAMP，将发生什么？
  
      每当行被更改时， 时间戳字段将获取当前时间戳。列设置为 AUTO INCREMENT 时， 如果在表中达到最大值， 会发生什么情况？它会停止递增， 任何进一步的插入都将产生错误， 因为密钥已被使用。
      
      怎样才能找出最后一次插入时分配了哪个自动增量？LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值， 并且不需要指定表名称。

### MySQL 里记录货币用什么字段类型好

      NUMERIC 和 DECIMAL 类型被 MySQL 实现为同样的类型， 这在 SQL92 标准允许。他们被用于保存值， 该值的准确精度是极其重要的值， 例如与金钱有关的数据。当声明一个类是这些类型之一时， 精度和规模的能被(并且通常是)指定。

### MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？

      **1、** 设计良好的数据库结构， 允许部分数据冗余， 尽量避免 join 查询， 提高效率。
    
      **2、** 选择合适的表字段数据类型和存储引擎， 适当的添加索引。
    
      **3、** MySQL 库主从读写分离。
    
      **4、** 找规律分表， 减少单表中的数据量提高查询速度。5、添加缓存机制， 比如 memcached， apc 等。
    
      **5、** 不经常改动的页面， 生成静态页面。
    
      **6、** 书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.

### 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。

      **1、如果A表TID是自增长,并且是连续的,B表的ID为索引**
    
      ```sql
      select * from a,b where a.tid = b.id and a.tid>500000 limit 200;

**2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。**

```sql
select * from b , (select tid from a limit 50000,200) a where b.id = a .tid; 
```

### myisamchk

它用来压缩 MyISAM 表， 这减少了磁盘或内存使用。

MyISAM Static 和 MyISAM Dynamic 有什么区别？

在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT， BLOB 等字段， 以适应不同长度的数据类型。

MyISAM Static 在受损情况下更容易恢复。

### 为什么要尽量设定一个主键?

主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.

### 主键使用自增ID还是UUID?

推荐使用自增ID,不要使用UUID.

因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.

总之,在数据量大一些的情况下,用自增主键性能会好一些.

关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.

> If you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index.
> 
> If you do not define a PRIMARY KEY for your table, MySQL picks the first UNIQUE index that has only NOT NULL columns as the primary key and InnoDB uses it as the clustered index.

### 字段为什么要求定义为not null?

MySQL官网这样介绍:

> NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.

null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.

### 如果要存储用户的密码散列,应该使用什么字段进行存储?

密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.

### 唯一索引比普通索引快吗, 为什么

唯一索引不一定比普通索引快, 还可能慢.

**1、查询时,** 在未使用`limit 1`的情况下, 在匹配到一条数据后, 唯一索引即返回, 普通索引会继续匹配下一条数据, 发现不匹配后返回. 如此看来唯一索引少了一次匹配, 但实际上这个消耗微乎其微.

**2、更新时** , 这个情况就比较复杂了. 普通索引将记录放到`change buffer`中语句就执行完毕了. 而对唯一索引而言, 它必须要校验唯一性, 因此, 必须将数据页读入内存确定没有冲突, 然后才能继续操作. 对于**写多读少**的情况, 普通索引利用`change buffer`有效减少了对磁盘的访问次数, 因此普通索引性能要高于唯一索引.

### 列值为NULL时，查询是否会用到索引？

在MySQL里NULL值的列也是走索引的。当然，如果计划对列进行索引，就要尽量避免把它设置为可空，MySQL难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。

### 以下语句是否会应用索引：SELECT FROM users WHERE YEAR(adddate) < 2007;

不会，因为只要列涉及到运算，MySQL就不会使用索引。

使用索引查询一定能提高查询的性能吗？为什么

通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.

> 1、索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:
> 2、基于一个范围的检索,一般查询返回结果集小于表中记录数的30%
> 3、基于非唯一性索引的检索

### 什么情况下设置了索引但无法使用

**1、** 以“%” 开头的 LIKE 语句， 模糊匹配

**2、** OR 语句前后没有同时使用索引

**3、** 数据类型出现隐式转化（ 如 varchar 不加单引号的话可能会自动转换为 int 型）

### MyISAM索引与InnoDB索引的区别？

- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

DROP和TRUNCATE

`DROP`和`TRUNCATE`是用于删除数据库表中数据的两个SQL命令，它们在功能和执行方式上有一些区别。

1. **功能不同**：
   - `DROP`命令用于完全删除数据库表，包括表的结构和数据。执行`DROP`命令后，表及其所有相关的索引、约束、触发器等都会被删除，无法恢复。
   - `TRUNCATE`命令用于删除表中的所有数据，但保留表的结构。执行`TRUNCATE`命令后，表的数据会被清空，但表的结构、索引、约束等保持不变。
2. **执行方式不同**：
   - `DROP`命令是一个DDL（数据定义语言）命令，需要立即执行，并且会立即生效。执行`DROP`命令后，表会被立即删除，无需提交事务。
   - `TRUNCATE`命令是一个DML（数据操作语言）命令，需要在事务中执行，并且会被事务提交时生效。执行`TRUNCATE`命令后，表的数据会被标记为可回滚状态，直到事务提交后才会生效。
3. **性能和效果不同**：
   - `DROP`命令执行速度较慢，因为它删除整个表及其相关对象。如果需要重新创建表，需要重新定义表结构、索引、约束等。
   - `TRUNCATE`命令执行速度较快，因为它只是删除表中的数据，并不涉及表结构的修改。同时，`TRUNCATE`命令在删除数据时会重置表的自增计数器（如果有的话），从而重新开始计数。
4. **权限要求不同**：
   - `DROP`命令通常需要更高的权限，因为它可以完全删除表和相关对象。
   - `TRUNCATE`命令通常需要较低的权限，因为它只删除表中的数据，而不涉及表结构的修改。
     总结来说，`DROP`命令用于完全删除表，包括结构和数据，而`TRUNCATE`命令用于删除表中的数据，但保留表的结构。执行方式、性能和权限要求等方面也有所不同。在使用这两个命令时，需要谨慎操作，确保不会误删除或丢失重要的数据。

简单说一说drop、delete与truncate的区别

SQL中的drop、delete、truncate都表示删除，但是三者有一些差别

> 1、delete和truncate只删除表的数据不删除表的结构
> 2、速度,一般来说: drop> truncate >delete
> 3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;
> 4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.

### drop、delete与truncate分别在什么场景之下使用？

**1、** 不再需要一张表的时候，用drop **2、** 想删除部分数据行时候，用delete，并且带上where子句 **3、** 保留表而删除所有数据的时候用truncate

上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?

在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.

当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.

### 非聚簇索引一定会回表查询吗?

不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.

举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行`select age from employee where age < 20`的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.

### 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?

MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.

### 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?

- 使用不等于查询,
- 列参与了数学运算或者函数
- 在字符串like时左边是通配符.类似于'%aaa'.
- 当mysql分析全表扫描比使用索引快的时候不使用索引.
- 当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.

以上情况,MySQL无法使用索引.

### Innodb使用的是哪种隔离级别呢?

InnoDB默认使用的是可重复读隔离级别.

### MySQL索引的注意事项

**1、联合索引遵循前缀原则**

```
KEY(a,b,c)WHERE a = 1 AND b = 2 AND c = 3WHERE a = 1 AND b = 2WHERE a = 1#以上SQL语句可以用到索引WHERE b = 2 AND c = 3WHERE a = 1 AND c = 3#以上SQL语句用不到索引
```

**2、LIKE查询，%不能在前**

```
WHERE name LIKE "%wang%"#以上语句用不到索引，可以用外部的ElasticSearch、Lucene等全文搜索引擎替代。
```

**3、** 列值为空（NULL）时是可以使用索引的，但MySQL难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在MySQL内部进行特殊处理。

**4、** 如果MySQL估计使用索引比全表扫描更慢，会放弃使用索引，例如：
表中只有100条数据左右。对于SQL语句WHERE id > 1 AND id < 100，MySQL会优先考虑全表扫描。

**5、** 如果关键词or前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到。

**6、* 列类型是字符串，查询时一定要给值加引号，否则索引失效

### Hash索引和B+树所有有什么区别或者说优劣呢?

首先要知道Hash索引和B+树索引的底层实现原理:

hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.

那么可以看出他们有以下的不同:

- hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.

因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.

- hash索引不支持使用索引进行排序,原理同上.
- hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.**AAAA**和**AAAAB**的索引没有相关性.
- hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.
- hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.

因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.

### 为什么用 B+ 树做索引而不用哈希表做索引?

**1、** 哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。

**2、** 如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。

**3、** 索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的**链表**，这样的话，查找的时间就会大大增加。

B-Tree 和 B+Tree

**区别**

1. B-Tree 的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+Tree 的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。
2. 在 B-Tree 中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+Tree 中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B-Tree 的性能好像要比 B+Tree 好，而在实际应用中却是 B+Tree 的性能要好些。因为 B+Tree 的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比 B-Tree 多，树高比 B-Tree 小，这样带来的好处是减少磁盘访问次数。尽管 B+Tree 找到一个记录所需的比较次数要比 B-Tree 多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+Tree 的性能可能还会好些，而且 B+Tree 的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+Tree 的缘故。

### 为什么 B+Tree 比 B-Tree 更适合实际应用中操作系统的文件索引和数据库索引？**

1. B+Tree 的磁盘读写代价更低

> B+Tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B-Tree 更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。

1. B+Tree 的查询效率更加稳定

> 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### 超键、候选键、主键、外键分别是什么？

**1、超键：** 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 **2、候选键：** 是最小超键，即没有冗余元素的超键。 **3、主键：** 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 **4、外键：** 在一个表中存在的另一个表的主键称此表的外键。

### 不可重复读和幻读区别

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

### UNION与UNION ALL的区别？

- 如果使用UNION ALL，不会合并重复的记录行
- 效率 UNION 高于 UNION ALL
