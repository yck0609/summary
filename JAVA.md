# 1 JAVA基本概念

## 1.1  JDK(Java Development Kit)、JRE(Java Runtime Environment)、JVM(Java Virtual Machine)

> `JDK`是用于开发`Java`应用程序的工具包，`JRE`是用于运行`Java`应用程序的环境，而`JVM`是在`JRE`中执行字节码的虚拟机

### 1.1.1 JDK

> `JDK` 是用于开发Java应用程序的工具包，包含 `Java` 编译器（javac）、Java虚拟机、Java类库、调试工具，提供开发、编译和调试Java应用程序所需的工具和资源

### 1.1.2 JRE

> JRE是运行Java应用程序所需的软件包，包含Java虚拟机和Java类库，用于解释和执行Java字节码

### 1.1.3 JVM

> JVM在物理计算机上模拟运行Java程序，提供了内存管理、垃圾回收、安全性等功能，使得Java程序能够在不同的操作系统和硬件平台上运行，实现Java"一次编写，到处运行"的特性

## 1.2 JAVA特性

1. **面向对象（Object-Oriented）**
   
   `Java` 是面向对象的编程语言，支持封装、继承和多态等面向对象的概念，使得代码具有可重用性、可扩展性和可维护性

2. **平台无关性（Platform-Independent）**
   
   `Java `具有"一次编写，到处运行"的特性，Java源代码编译后生成字节码（`Bytecode`），可以在任何支持 JVM 的平台上运行，提高了跨平台开发的效率

3. **自动内存管理（Automatic Memory Management）**
   
   `Java` 提供垃圾回收机制，自动管理对象的内存分配和释放，不需要手动管理内存，减少了内存泄漏和野指针等常见的内存错误

4. **异常处理（Exception Handling）**
   
   `Java` 提供异常处理机制捕获和处理程序中的异常情况

5. **多线程支持（`Multithreading`）**
   
   `Java` 支持多线程编程，可以创建和管理多个线程，实现并发执行程序

6. **安全性（Security）**
   
   `Java`具有强大的安全性特性，包括沙箱安全模型、字节码校验和安全管理器等，保护系统免受恶意代码和安全漏洞的影响

7. **高性能（High Performance）**
   
   `Java`是解释执行语言，但通过即时编译（`Just-In-Time Compilation`）技术和优化手段，`Java`程序的性能接近于编译型语言

## 1.3 面向对象（Object-Oriented Programming，OOP）

> `Java`是面向对象的编程语言，面向对象是Java的核心特性之一。面向对象编程是一种编程范式，通过将数据和操作封装在对象中，模拟现实世界中的实体和其相互关系，使得代码更具可读性、可维护性和可扩展性。在`Java`中，一切皆为对象，类是对象的模板，对象是类的实例

1. **类（Class）**
   
   类是定义对象的模板，描述对象的属性（成员变量）和行为（方法），封装数据和操作

2. **对象（Object）** 
   
   对象是类的实例，通过关键字`new`创建对象，每个对象都有自己的状态（属性值）和行为（方法调用）

3. **封装（Encapsulation）**
   
   封装是将数据和操作封装在类中的机制。通过封装，类可以隐藏内部实现细节，只暴露必要的接口供外部使用，提供了数据的安全性和灵活性

4. **继承（Inheritance）**
   
   继承是一种类之间的关系，通过继承，一个类可以继承另一个类的属性和方法，实现了代码的重用性。被继承的类称为父类或超类，继承的类称为子类或派生类

5. **多态（Polymorphism）**
   
   多态是指同一种操作可以在不同的对象上具有不同的行为。在Java中，多态通过方法重写（Override）和方法重载（Overload）实现，提供了代码的灵活性和扩展性

6. **抽象（Abstraction）**
   
   抽象是将类的共同特征提取出来形成抽象类或接口。抽象类定义了一组抽象方法和非抽象方法，不能被实例化，只能被继承。接口定义了一组抽象方法，提供一种规范和约束

### 1.3.1 封装（Encapsulation）

> 封装将数据和对数据的操作封装在类中，并通过访问修饰符控制对数据的访问，隐藏类的内部实现细节，同时提供对外部代码的安全访问接口

1. **数据隐藏和安全性** ：封装将类的内部数据隐藏，只允许通过公共的访问方法来访问和修改数据，保护数据不被意外修改，提高数据的安全性

2. **代码重用** ：通过封装，对象对外提供统一的访问接口，使得对象可以被多个模块或组件共同使用，而不必担心内部实现发生变化而导致外部代码需要修改

### 1.3.2 继承（Inheritance）

> 继承允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。继承通过关键字`extends`实现，子类使用`extends`关键字父类声明继承关系，子类可以继承父类的非私有成员变量和方法，并可以重写父类的方法

1. **代码重用** ：通过继承，子类可以重用父类的属性和方法，避免了重复编写相似代码，提高代码的重用性，减少代码量

2. **扩展功能** ：子类可以在父类的基础上添加新的属性和方法，或者修改父类的行为，可以通过扩展现有类来实现新的功能，而无需修改原有的类

3. **多态性** ：继承是实现多态性的基础。通过将父类的引用指向子类的对象，可以以统一的方式操作不同的子类对象，提高代码的灵活性和可扩展性

### 1.3.3 多态（Polymorphism）

> 多态允许使用父类的引用来引用子类的对象，并根据实际引用的对象类型来调用相应的方法。多态性通过继承和方法重写实现的，当一个父类引用指向一个子类对象时，根据实际对象的类型来调用相应的方法

1. **方法重写** ：子类可以重写父类的方法，即在子类中重新定义与父类中具有相同名称和参数列表的方法。方法重写允许子类根据自身的特定需求重新实现方法的行为

2. **动态绑定** ：在运行时确定要调用的方法实现。当使用父类引用指向子类对象时，方法的调用将根据实际对象的类型进行动态绑定。这意味着在运行时会选择正确的方法实现，而不是在编译时确定

### 1.3.4 面向对象设计原则

> 面向对象设计原则用于指导面向对象软件的设计过程，目的是提高代码的可维护性、可扩展性和可重用性，降低代码的耦合度
> 
> 1. **单一职责原则（Single Responsibility Principle，SRP）**
>    
>    一个类应该只有单一的责任，提高类的<mark>内聚性</mark>，易于理解、维护和重用
> 
> 2. **开放封闭原则（Open-Closed Principle，OCP）**
>    
>    软件实体（类、模块、函数等）应该<mark>对扩展开放，对修改封闭</mark>，保证代码的稳定性，减少引入错误的风险
> 
> 3. **里氏替换原则（Liskov Substitution Principle，LSP）**
>    
>    子类遵循父类定义的行为约束，<mark>子类能替换其父类</mark>并且不会影响程序的正确性，保证代码的一致性和可扩展性
> 
> 4. **依赖倒置原则（Dependency Inversion Principle，DIP）**
>    
>    <mark>高层模块不依赖于低层模块</mark>，二者都依赖于抽象，抽象不依赖于细节，细节依赖于抽象<
> 
> 5. **接口隔离原则（Interface Segregation Principle，ISP）**
>    
>    客户端不应该依赖于它不需要的接口，接口应该精简而专一
> 
> 6. **合成复用原则（Composite Reuse Principle，CRP）**
>    
>    优先使用对象组合，减少继承的使用
> 
> 7. **迪米特法则（Law of Demeter，LoD）**
>    
>    只与直接朋友通信，不要深入了解陌生对象

## 1.4 JAVA编程规约

### 1.4.1 命名风格

> 1. 命名均<mark>不能以下划线或美元符号开始</mark>，也<mark>不能以下划线或美元符号结束</mark>
> 
> 2. <mark>类名使用UpperCamelCase</mark>风格，除了：DO / BO / DTO / VO / AO / PO / UID
> 
> 3. <mark>方法名、参数名、变量名使用lowerCamelCase风格</mark>
> 
> 4. 常量命名全部大写，单词间用下划线隔开
> 
> 5. 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾

### 1.4.2 赋值规范

> 1. 在long或者Long赋值时，数值后使用大写的L，不能是小写的l，必须加L！
> 
> 2. float或Float赋值时，数值后使用f或F，必须加f！

# 2 数据类型

> Java中的数据类型可以分为基本数据类型和引用数据类型。变量必须先声明后使用，并且要指定其数据类型。基本数据类型的变量直接存储数据的值，而引用数据类型的变量存储的是对象的引用

## 2.1 基本数据类型（Primitive Types）

### 2.1.1 整数类型

- **byte**: 占用 <mark>1</mark> 个字节，范围为 -128 到 127

- **short**: 占用 <mark>2</mark> 个字节，范围为 -32,768 到 32,767

- **int**: 占用 <mark>4</mark> 个字节，范围为 -2,147,483,648 到 2,147,483,647

- **long**: 占用 <mark>8</mark> 个字节，范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807

### 2.1.2 浮点数类型

- **float**: 存储单精度浮点数，占用 4 个字节，范围为约 -3.4E+38 到 +3.4E+38

- **double**: 存储双精度浮点数，占用 8 个字节，范围为约 -1.8E+308 到 +1.8E+308

### 2.1.3 字符类型

- **char**: 存储单个字符，占用 2 个字节，范围为 '\u0000' 到 '\uffff'，也可以表示 Unicode 字符

### 2.1.4 布尔类型

- **boolean**: 存储布尔值，占用 1个字节，只能取 true 或 false

### 2.1.5 基本数据类型对比

| 数据类型    | 字节  | 默认值      | 范围                                                     |
|:-------:|:---:|:--------:|:------------------------------------------------------:|
| boolean | 1   | false    | true 或 false                                           |
| byte    | 1   | 0        | -128 到 127                                             |
| short   | 2   | 0        | -32,768 到 32,767                                       |
| int     | 4   | 0        | -2,147,483,648 到 2,147,483,647                         |
| long    | 8   | 0L       | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| float   | 4   | 0.0f     | -3.40282347E+38 到 +3.40282347E+38                      |
| double  | 8   | 0.0      | -1.7976931348623157E+308 到 +1.7976931348623157E+308    |
| char    | 2   | '\u0000' | '\u0000' 到 '\uffff'（0 到 65,535）                        |

## 2.2 引用数据类型（Reference Types）

### 2.2.1 类

> 通过类可以创建对象，访问对象的属性和调用对象的方法

### 2.2.2 接口

> 接口定义了一组抽象方法，用于描述类的行为。类可以实现一个或多个接口，实现接口中定义的方法

### 2.2.3 枚举

> 枚举用于定义一组常量。枚举类型可以限制变量的取值范围

## 2.3 包装类（Wrapper Classes）

> 包装类是引用数据类型，用于将基本数据类型包装成对象

1. **Boolean**：提供对boolean的封装和操作方法
2. **Byte**：提供对byte的封装和操作方法
3. **Short**：提供对short的封装和操作方法
4. <mark>**Integer**</mark>：提供对int的封装和操作方法
5. **Long**：提供对long的封装和操作方法
6. **Float**：提供对float的封装和操作方法
7. **Double**：提供对double的封装和操作方法
8. **<mark>Character</mark>** ：提供对字符值的封装和操作方法

### 2.3.1 包装类常用方法

> **1. 基本数据类型与包装类转换**
> 
> - `Integer.valueOf(int i)`：将基本数据类型转换为对应的包装对象
> 
> - `intValue()`：将包装对象转换为对应的基本数据类型
> 
> **2. 字符串与包装类转换**
> 
> - `toString()`：将包装对象转换为字符串
> 
> - `Integer.parseInt(String s)`：将字符串转换为对应的基本数据类型
> 
> **3. 值范围方法：**
> 
> - `Integer.MAX_VALUE`：返回包装类型的最大值
> 
> - `Integer.MIN_VALUE`：返回包装类型的最小值

### 2.3.2 自动装箱（Autoboxing）/ 自动拆箱（Unboxing）

> 自动装箱和自动拆箱用于在基本数据类型和对应的包装类之间进行转换

- **自动装箱** ：将基本数据类型赋值给包装类对象时，编译器会自动进行装箱操作，将基本数据类型包装成对应的包装类对象

- **自动拆箱** ：将包装类对象赋值给基本数据类型时，编译器会自动进行拆箱操作，将包装类对象中的值提取出来赋给基本数据类型

## 2.4 泛型（Generics）

> 泛型允许在定义类、接口和方法时使用一个或多个类型参数，使得这些类型可以在使用时被指定，提高代码的重用性、类型安全性和可读性，避免了在运行时出现类型转换错误

### 2.4.1 泛型基本概念

> 1. **类型参数（Type Parameters）**
>    
>    在定义类、接口或方法时，使用尖括号`<>`内的标识符来表示类型参数
> 
> 2. **类型变量（Type Variables）**
>    
>    类型变量可以用于定义类的成员变量、方法参数和返回类型，它们在使用时会被具体的类型替换
> 
> 3. **类型约束（Type Bounds）**
>    
>    可以对类型变量进行约束，限制它们的类型范围，如指定上界（使用关键字`extends`）和下界（使用关键字`super`）
> 
> 4. **泛型类（Generic Class）**
>    
>    使用泛型的类被称为泛型类，可以在类的定义中指定一个或多个类型参数
> 
> 5. **泛型接口（Generic Interface）**
>    
>    使用泛型的接口被称为泛型接口，可以在接口的定义中指定一个或多个类型参数
> 
> 6. **泛型方法（Generic Method）**
>    
>    使用泛型的方法被称为泛型方法，可以在方法的定义中指定一个或多个类型参数

### 2.4.2 泛型类（Generic Class）

> 泛型类在定义中指定一个或多个类型参数，从而使得类中的成员变量、方法参数和返回类型可以使用这些类型参数

- **类型安全性** 
  
  通过使用泛型类，编译器可以在编译时检查类型的一致性，避免了在运行时出现类型转换错误

- **代码重用** 
  
  泛型类可以提供通用的实现，可以在不同的地方使用相同的类定义，只需通过指定不同的类型参数来适应不同的需求

- **灵活性** 
  
  使用泛型类可以处理多种类型的数据，而无需为每种类型编写单独的类

### 2.4.3 泛型方法（Generic Method）

> 泛型方法在方法的定义中指定一个或多个类型参数，从而使得方法的参数类型、返回类型或局部变量的类型可以使用这些类型参数

- **类型安全性**
  
  通过使用泛型方法，编译器在编译时检查类型的一致性，避免了在运行时出现类型转换错误

- **灵活性**
  
  泛型方法可以处理多种类型的数据，而无需为每种类型编写单独的方法

- **代码重用**
  
  泛型方法可以提供通用的实现，可以在不同的地方使用相同的方法定义，只需通过指定不同的类型参数来适应不同的需求

# 3 关键字

> 关键字是被编程语言保留并具有特殊含义的单词，在语法规则中有特定的用途，不能被用作标识符（例如变量名、方法名等）或其他用途

1. **`import`**：用于导入其他包中的类

2. **`package`**：用于定义包

3. **`class`**：用于定义类

4. **`interface`**：用于定义接口

5. **`enum`**：用于定义枚举类型

6. **`new`**：用于创建对象实例

7. **`extends`**：用于表示类的继承关系，子类继承父类

8. **`implements`**：用于表示类实现接口

9. **`abstract`**：用于声明抽象类和抽象方法。抽象类是不能被实例化的类，而抽象方法是只有声明而没有实现的方法

10. **`static`**：表示静态关键字，用于定义静态变量、静态方法和静态代码块

11. **`final`**：用于声明不可变的实体，包括变量、方法和类

12. **`void`**：表示无返回值

13. **`native`**：用于表示方法使用本地（非Java）实现

14. **`private`**：表示私有访问修饰符，限制只能在当前类中访问

15. **`protected`**：表示受保护访问修饰符，限制只能在当前类及其子类和同一包中访问

16. **`public`**：表示公共访问修饰符，没有访问限制

17. **`return`**：用于从方法中返回值

18. **`assert`**：用于进行断言检查，用于在代码中插入一些条件判断，如果条件不满足，则抛出`AssertionError`异常

19. **`for`**：用于定义循环结构，指定循环的初始条件、循环条件和循环迭代方式

20. **`do`**：用于定义循环体，先执行循环体，再进行循环条件判断

21. **`while`**：用于定义循环结构，先进行循环条件判断，再执行循环体

22. **`if`**：用于进行条件判断，根据条件的真假执行不同的代码块

23. **`else`**：用于定义`if`语句的可选分支，当`if`条件不满足时执行

24. **`break`**：用于跳出循环或`switch`语句，使程序执行流程终止当前循环或`switch`块

25. **`continue`**：用于终止当前循环的迭代，然后继续下一次迭代

26. **`switch`**：用于多重条件判断，根据不同的情况执行不同的代码块

27. **`case`**：在`switch`语句中用于定义不同的情况

28. **`default`**：在`switch`语句中用于定义默认情况

29. **`this`**：表示当前对象的引用

30. **`super`**：用于在子类中调用父类的构造方法、成员变量和成员方法

31. **`throw`**：用于抛出异常

32. **`throws`**：用于声明方法可能抛出的异常

33. **`try`**：用于定义异常处理的代码块

34. **`catch`**：用于捕获异常，跟在`try`语句块之后，用于处理可能发生的异常情况

35. **`finally`**：用于定义在`try`语句块中的代码执行完毕后必须执行的代码块，无论是否发生异常

36. **`instanceof`**：用于判断一个对象是否属于某个类或实现了某个接口

37. **`synchronized`**：用于实现线程同步，确保多个线程按照预期的顺序执行

38. **`goto`**：已保留，但不建议使用

39. **`strictfp`**：用于确保浮点运算精度一致

40. **`transient`**：用于表示变量不参与序列化

41. **`volatile`**：用于保证变量的可见性和禁止指令重排序

## 3.1 权限修饰符

> 权限修饰符用于控制类、变量、方法和构造函数的可访问性

1. **public** : `public`修饰的类、变量、方法和构造函数可以从任何地方访问，无访问限制

2. **protected** : `protected`修饰的变量、方法和构造函数对于同一包中的类以及所有子类都是可访问的

3. **default** : `default`修饰的类、变量、方法和构造函数只能在同一包中访问，如果没有指定任何修饰符，默认为`default`修饰符

4. **private** : `private`修饰的变量、方法和构造函数只能在定义它们的类内部访问，对于外部类或其他类都是不可访问的
   
   | 修饰符       | 类内部访问 | 同一包中的类 | 子类  | 不同包中的类 |
   |:---------:|:-----:|:------:|:---:|:------:|
   | public    | ✔️    | ✔️     | ✔️  | ✔️     |
   | protected | ✔️    | ✔️     | ✔️  | ❌      |
   | default   | ✔️    | ✔️     | ❌   | ❌      |
   | private   | ✔️    | ❌      | ❌   | ❌      |

## 3.2 类、方法和变量的声明

### 3.2.1 extends

> `extends` 关键字用于创建类的继承关系，一个类可以继承另一个类的属性和方法，从而形成父类和子类之间的关系

- 子类可以访问父类的公共和受保护成员，但不能直接访问父类的私有成员

- 子类可以重写父类的方法，以实现自己的行为

- Java 不支持多重继承，即一个类不能直接继承多个类

### 3.2.2 implements

> `implements` 关键字用于实现接口

- 一个类可以实现一个或多个接口，即多实现

- 实现接口的类必须提供接口中定义的<mark>所有方法</mark>的实现，如果类没有实现接口中的所有方法，那么该类必须声明为抽象类

- 接口中的方法默认是公共的抽象方法，因此在实现接口时，方法的访问修饰符必须是`public`

### 3.2.3 abstract

> `abstract` 关键字用于声明抽象类和抽象方法

#### 3.2.3.1 抽象类（Abstract Class）

抽象类通常用作其他类的基类，用于定义通用的属性和方法

> - 抽象类不能被实例化，只能被继承
> 
> - 抽象类不能被声明为`final`，因为它需要被继承
> 
> - 抽象类可以包含具体的方法实现，子类可以直接继承并使用这些具体方法

#### 3.2.3.2 抽象方法（Abstract Method）

<mark>抽象方法声明在抽象类中</mark>，且抽象类必须是抽象方法所在类的直接或间接父类

> - 抽象方法只有方法的声明，没有具体的实现
> 
> - 子类继承抽象类后，必须实现抽象类中的<mark>所有抽象方法</mark>，除非子类自身也声明为抽象类
> 
> - 抽象方法不能被声明为`private`，因为子类需要访问和实现这些抽象方法

### 3.2.4 static

> `static` 关键字用于声明静态成员（静态字段和静态方法）以及静态代码块。静态成员属于类而不是实例，可以在类的任何地方访问。静态成员在类加载时被初始化，并且对于所有类的实例来说，它们都具有相同的值

1. **静态字段**（Static Fields）
   
   静态字段在类加载时被初始化，可以在类的任何地方访问，可以通过类名直接访问，无需创建类的实例

2. **静态方法**（Static Methods）
   
   静态方法可以直接通过类名调用，无需创建类的实例

3. **静态代码块**（Static Blocks）
   
   <mark>静态代码块中的代码会在类加载时执行，在类的静态字段和静态方法之前执行</mark>，并且只执行一次

### 3.2.5 synchronized

> `synchronized` 关键字应用于方法和代码块实现线程同步和互斥访问，保证线程安全。当一个线程进入同步方法或代码块时，线程会尝试获取锁。如果锁没有被其他线程占用，该线程将获得锁并执行同步代码。如果锁已经被其他线程占用，该线程将被阻塞，直到获取到锁为止。`synchronized` 可能会导致线程的等待和阻塞，影响程序的性能

1. **同步方法** 
   
   方法被声明为`synchronized`，同一时间只能有一个线程访问该方法，其他线程必须等待当前线程执行完毕才能访问该方法

2. **同步代码块** 
   
   使用对象作为锁来确保同步，使用`synchronized`关键字来修饰一段代码块，同一时间只能有一个线程执行同步代码块

### 3.2.6 transient

> `transient` 关键字修饰变量影响对象的默认序列化机制，表示该变量不会被默认的序列化机制序列化，在对象序列化时该成员变量的值不会被保存到字节流中，在反序列化时被初始化为默认值

### 3.2.7 volatile

> `volatile`  关键字修饰变量实现变量的可见性和禁止指令重排序， 不涉及线程的阻塞和唤醒，开销较低。然而，`volatile` 只能保证单个变量的原子性操作，无法保证复合操作的原子性

1. **可见性（Visibility）** 
   
   `volatile `变量的修改会立即刷新到主内存，并且其他线程读取该变量时会直接从主内存中获取最新值，而不是使用线程本地的缓存当一个线程，修改了`volatile` 变量的值，其他线程能够立即看到最新的值

2. **禁止指令重排序（Ordering）** 
   
   `volatile` 变量的读写操作会被插入内存屏障（Memory Barrier），对 `volatile` 变量的操作不能被重排序到内存屏障之前或之后的位置。这保证了在多线程环境下，对 `volatile` 变量的操作按照程序中的顺序执行，避免了出现意外的结果

### 3.2.8 final

> `final` 关键字用于声明不可变的实体，包括变量、方法和类。使用`final`关键字可以使得相应的实体具有不可修改的特性

1. **final变量**
   
   使用`final`关键字声明的变量称为常量，一旦被赋值后就不能再被修改。常量必须在声明时或构造函数中进行初始化，且不能再被修改

2. **final方法**
   
   使用`final`关键字修饰的方法称为最终方法，即不能被子类重写

3. **final类**
   
   使用`final`关键字修饰的类称为最终类，即不能被继承

## 3.3 异常处理

### 3.3.1 finally

> `finally`  关键字定义代码块表示无论是否发生异常，都会执行其中的代码，通常用于释放资源、清理操作

1. `finally` 块中的代码在以下情况下不会执行：
   
   - 在 `try` 块中发生了未捕获的异常，导致程序终止
   
   - 在 `try` 块中发生了 `System.exit()` 方法的调用，导致程序终止

2. <mark>finally块中的代码在 return`语句执行之前执行</mark>

### 3.3.2 throw

> `throw` 关键字用于在程序中主动抛出异常，抛出的异常对象可以是一个已存在的异常对象或者通过 `new` 关键字创建的新异常对象

### 3.3.3 throws

> 使用 `throws` 关键字在方法签名中声明可能抛出的异常，异常类型可以是 Java 内置的异常类或自定义异常类

## 3.4 其他关键字

### 3.4.1 this

> `this`  关键字用于引用当前对象、当前对象的成员变量、成员方法和构造方法

1. 引用当前对象的成员变量和成员方法 ：使用 `this` 关键字引用当前对象的成员变量和成员方法，当成员变量和局部变量同名时，使用 `this` 关键字指定当前对象的成员变量

2. 调用当前对象的构造方法 ：使用 `this` 关键字来调用同一类中的其他构造方法，`this` 关键字调用构造方法的语句必须是构造方法的<mark>第一条语句</mark>

3. 返回当前对象 ：使用 `return this` 在方法链式调用时返回当前对象

### 3.4.2 super

> `super`  关键字用于引用父类的成员变量、成员方法和构造方法

1. 引用父类的成员变量和成员方法 ：在子类中使用 `super` 关键字引用父类的成员变量和成员方法，当子类和父类拥有同名的成员变量或成员方法时，使用 `super` 关键字可以指定访问父类成员

2. 调用父类的构造方：在子类的构造方法中使用 `super` 关键字来调用父类的构造方法，`super` 关键字调用父类构造方法的语句必须是子类构造方法的第一条语句

### 3.4.3 instanceof

> `instanceof` 关键字用于检查一个对象是否是指定类或其子类的实例

```java
object instanceof class // object是要检查的对象，class是要检查的类或接口
```

# 4 注解（Annotations）

> 注解是一种在代码中添加元数据的方式，提供关于程序的额外信息，可以用于配置、文档化和执行代码。注解使用 **`@`** 符号紧跟着注解名称的方式进行标记，可以应用于类、方法、字段、参数等元素上

## 4.1 元注解（Meta-Annotations）

>  元注解是用于注解其他注解的注解，可以用于自定义注解的行为和用途

### 4.1.1 @Retention

> **``@Retention``** 注解用于<mark>指定注解的生命周期</mark>，其参数 **``RetentionPolicy``** 可以接受三个预定义的枚举值：
> 
> 1. **``RetentionPolicy.SOURCE``**：表示注解仅在源代码中存在，编译后的字节码文件中不保留，用于提供给编译器使用，对运行时环境没有任何影响
> 
> 2. **``RetentionPolicy.CLASS``**：表示注解在编译后的字节码文件中存在，但在运行时环境中不可用，用于提供给编译器和运行时环境使用，对程序的执行没有直接影响
> 
> 3. **``RetentionPolicy.RUNTIME``**：表示注解在编译后的字节码文件中存在，并且在运行时环境中可用，用于提供给运行时环境使用，可以通过反射机制在运行时获取并处理注解信息

### 4.1.2 @Target

> `@Target` 用于<mark>指定注解应用的目标元素类型</mark>，通过给定参数 `ElementType`的值指定注解可以应用的目标元素类型
> 
> 1. `ElementType.TYPE`：表示注解可以应用于类、接口、枚举等类型的声明
> 
> 2. `ElementType.METHOD`：表示注解可以应用于方法的声明
> 
> 3. `ElementType.FIELD`：表示注解可以应用于字段的声明
> 
> 4. `ElementType.PARAMETER`：表示注解可以应用于方法的参数声明
> 
> 5. `ElementType.CONSTRUCTOR`：表示注解可以应用于构造函数的声明
> 
> 6. `ElementType.LOCAL_VARIABLE`：表示注解可以应用于局部变量的声明
> 
> 7. `ElementType.ANNOTATION_TYPE`：表示注解可以应用于注解的声明
> 
> 8. `ElementType.PACKAGE`：表示注解可以应用于包的声明

### 4.1.3 @Documented

> `@Documented` 用于指示自定义注解应该包含在生成的Java文档中。自定义注解默认情况下不会包含在Javadoc之类的工具生成的文档中

### 4.1.4 @Inherited

> `@Inherited`用于<mark>指示注解是否可以被继承</mark>。默认情况下注解不可被继承，如果一个类使用了某个注解，那么它的子类不会自动继承该注解。然而，通过在注解声明上添加`@Inherited`注解，可以使得该注解可以被子类继承

## 4.2 标准注解（Standard Annotations）

> 标准注解注解是Java SE库中提供的常用注解

### 4.2.1 @Override

> `@Override` 用于标识一个方法是<mark>重写</mark>父类中的方法。当一个子类继承自父类，并且子类中定义了一个与父类中<mark>具有相同名称、参数列表和返回类型</mark>的方法时，可以使用`@Override`注解来明确表示该方法是对父类方法的重写

### 4.2.2 @Deprecated

> `@Deprecated`用于标识一个类、方法、字段或构造函数已经<mark>过时</mark>，并且在将来的版本中可能会被移除，有助于维护代码的兼容性和可维护性

### 4.2.3 @SuppressWarnings

> `@SuppressWarnings` 注解用于<mark>抑制编译器产生的警告信息</mark>，设定字符串参数用于指定要抑制的警告类型

### 4.2.4 @SafeVarargs

> `@SafeVarargs` 用于在可变参数方法（varargs method）中消除由于参数化类型数组的类型安全问题而产生的警告。可变参数方法是指允许传入可变数量参数的方法，使用省略号（…）来表示。在使用可变参数方法时，由于参数传递的是一个数组，可能会导致类型安全问题。这是因为Java中的可变参数是通过将参数打包成数组来实现的，而数组是协变的，即可以将子类型的数组赋值给父类型的数组。这可能导致在方法内部进行泛型操作时出现类型不匹配的情况。当可变参数方法使用 `@SafeVarargs`注解进行标记时，编译器将不会产生关于参数化类型数组类型安全的警告

### 4.2.5 @FunctionalInterface

> `@FunctionalInterface` 用于标记接口是一个函数式接口，并提供了编译时检查。如果一个接口被 `@FunctionalInterface`注解标记，但实际上包含多个抽象方法，编译器将会报错。函数式接口是指只包含一个抽象方法的接口

# 5 异常（Exception）

> 异常是指在程序执行过程中可能出现的错误或异常情况，当程序遇到异常时，会抛出异常对象，如果没有适当的处理机制，程序将会终止执行

## 5.1 异常分类

### 5.1.1 Throwable

> `Throwable` 是所有异常的根类，具有两个子类：`Error` 和 `Exception`
> 
> - **Error**：Error表示严重的错误，通常由虚拟机抛出
> - **Exception**：Exception表示程序运行过程中的异常情况

### 5.1.2 可检查异常（Checked Exception）

> 可检查异常在编译时期就需进行处理，否则编译器会报错
> 
> - **IOException**：输入输出异常，例如文件操作时可能抛出的异常
> - **SQLException**：数据库操作异常，例如执行SQL语句时可能抛出的异常
> - **ClassNotFoundException**：类未找到异常，例如在使用反射时可能抛出的异常

### 5.1.3 不可检查异常（Unchecked Exception）

> 不可检查异常在编译时期不需要强制处理，也不需要在方法签名中声明
> 
> - **RuntimeException**：RuntimeException是不可检查异常的基类
> - **<mark>NullPointerException</mark>**：空指针异常，表示访问了空对象
> - **<mark>ArrayIndexOutOfBoundsException</mark>**：数组越界异常，表示访问的数组索引无效
> - **<mark>ArithmeticException</mark>**：算术异常，例如除以零
> - **<mark>IllegalArgumentException</mark>**：非法参数异常，表示传递了非法的参数
> - **<mark>ClassCastException</mark>**：类转换异常，表示发生了无效的类型转换

## 5.2 异常处理

### 5.2.1 抓抛模型（try-catch-finally）

> 使用`try`块来包含可能抛出异常的代码，使用`catch`块捕获并处理异常，使用`finally`块来执行无论是否发生异常都必须执行的清理代码
> 
> 1. 捕获异常 ：使用`try-catch`块来捕获并处理异常。`try`块中包含可能抛出异常的代码，`catch`块用于捕获并处理异常。当异常发生时，程序会跳转到`catch`块，执行相应的异常处理逻辑
> 
> 2. 处理异常：在多个`catch`块中捕获异常时，应该按照从具体到通用的顺序进行处理。将特定类型的异常放在前面的`catch`块中，通用的异常类型（如`Exception`）放在后面的`catch`块中
> 
> 3. 抛出异常 ：当程序执行过程中发生异常时，使用`throw`关键字手动抛出异常
> 
> 4. finally块：`finally`块用于包含无论是否发生异常都必须执行的代码。无论异常是否被捕获，`finally`块中的代码都会被执行

### 5.2.2 throws关键字

> `throws`关键字用于在方法签名中声明方法可能抛出的异常，将异常的处理责任交给调用该方法的代码。调用方法的代码可以继续使用抓抛模型来处理异常，或者将异常继续向上层方法传递

### 5.2.3 异常链（Exception Chaining）

> 当一个方法捕获到异常后，有时候希望抛出一个新的异常，并将原始异常作为新异常的原因（cause）。这样可以提供更详细的异常信息，帮助调试和定位问题。Java中的异常类提供了一个构造函数，接受一个`Throwable`类型的参数，用于指定原始异常。通过这种方式，可以构建一个异常链，将原始异常与新异常关联起来

### 5.2.4 自定义异常类

> 除了使用内置的异常类，还可以继承`Exception`或`RuntimeException`类自定义异常类，提供更具体的异常类型，并添加自定义的异常信息和行为

# 6 集合框架（Collection Framework）

> 集合框架位于`java.util`包中，是一组用于存储和操作对象的类和接口，提供统一的方式来处理和操作集合数据，使得开发人员可以更方便地管理和操作多个元素

## 6.1 接口继承关系和实现

> 1. **Collection** ：`Collection` 是集合框架的根接口，定义了基本的集合操作，如添加、删除、查询、遍历等。`Collection` 有两个主要的子接口：
>    
>    - **List**：表示有序的集合，可以包含重复元素
>    
>    - **Set**：表示不重复的集合，不允许包含重复元素
> 
> 2. **Map**：`Map` 表示键值对的映射集合，每个元素都包含一个键和对应的值

![](https://img-blog.csdn.net/20180803195348216?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaXlhbmFmZmVjdGlvbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 6.2 List

> `List` 接口继承`Collection`接口，用于储存<mark>重复有序</mark>元素

### 6.2.1 常用方法

1. boolean add(E element) : 在列表末尾添加指定元素，并返回`true`

2. void add(int index, E element) : 在指定索引位置插入指定元素

3. boolean addAll(Collection<? extends E> collection) : 将指定集合中的所有元素添加到列表末尾

4. E get(int index) : 返回指定索引处的元素

5. int indexOf(Object element) : 返回指定元素第一次出现的索引

6. int lastIndexOf(Object element) : 返回指定元素最后一次出现的索引

7. E remove(int index) : 移除并返回指定索引处的元素

8. boolean remove(Object element) : 从列表中删除指定元素

9. boolean removeAll(Collection<?> collection) : 删除列表中与指定集合中元素相同的所有元素

10. E set(int index, E element) : 替换指定索引处的元素，并返回原始元素

11. int size() : 返回列表中的元素数量

12. boolean isEmpty() : 判断列表是否为空

13. void clear() : 清空列表中的所有元素

14. boolean contains(Object element) : 判断列表是否包含指定元素

15. Iterator<E> iterator() : 返回在列表上进行迭代的迭代器

### 6.2.2 ArrayList

> `ArrayList` 底层由数组实现，允许通过索引对元素进行快速随机访问。缺点是每个元素之间不能有间隔，当数组大小不足进行扩容时，需要将已有数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高

### 6.2.3 Vector

> `Vector` 底层由数组实现，支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步花费较高

### 6.2.4 LinkedList

> `LinkedList` 底层由链表实现，适合数据的动态插入和删除，随机访问和遍历速度较慢。`LinkedList` 还实现了 `Deque`接口，可用作队列或栈

- **``addFirst(E element)``**：将元素添加到链表的开头
- **``addLast(E element)``**：将元素添加到链表的末尾
- **``removeFirst()``**：移除并返回链表的第一个元素
- **``removeLast()``**：移除并返回链表的最后一个元素
- **``getFirst()``**：返回链表的第一个元素
- **``getLast()``**：返回链表的最后一个元素

### 6.2.5 对比

| 特性      | ArrayList        | Vector | LinkedList |
|:-------:|:----------------:|:------:|:----------:|
| 底层实现    | 数组               | 数组     | 双向链表       |
| 随机访问    | 支持               | 支持     | 不支持        |
| 插入/删除操作 | 相对较慢             | 相对较慢   | 相对较快       |
| 线程安全    | <mark>不安全</mark> | 安全     | 不安全        |

## 6.3 Set

> `Set` 用于存储不重复无序(存入和取出的顺序不一定相同)元素。元素的唯一性通过对象`hashCode`值保证。向 `Set` 中添加元素时，只有该元素的 `hashCode()` 和 `equals()` 方法都返回`true`时，`Set` 认为元素是重复的，不将其添加到集合中

### 6.3.1 常用方法

1. **``add(element)``** :将指定元素添加到集合中，若元素已经存在则返回 `false`

2. **``remove(element)``** ：从集合中移除指定元素，若元素存在，则移除并返回``true``，否则返回 ``false``

3. **``contains(element)``** ：检查集合中是否包含指定元素。如果存在，则返回``true``；否则返回``false``

4. **``size()``**: 返回集合中元素数量

5. **``isEmpty()``**: 检查集合是否为空

6. **``clear()``**: 清空集合中的所有元素

7. **``iterator()``**: 返回一个用于迭代集合元素的迭代器

### 6.3.2 HashSet

> `HashSet` 使用哈希表来存储元素，不保证元素的顺序
> 
> - 内部使用哈希表实现，具有较快的插入、删除和查找操作
> - <mark>允许使用 `null`元素</mark>
> - 元素不可重复，如果向 **``HashSet``** 中添加重复元素，添加操作将被忽略
> - 不保证元素的存储顺序，因为它是根据元素的哈希码进行存储和检索的

### 6.3.3 TreeSet

> ``TreeSet``  实现 ``SortedSet`` 接口，使用红黑树存储元素，能够保持元素的有序性
> 
> - 内部使用红黑树（自平衡二叉搜索树）实现，具有排序功能，可按照自然顺序或自定义的比较器进行排序
> 
> - 元素必须是可比较的（实现了`Comparable`接口或通过构造函数提供了`Comparator`）
> 
> - 元素的存储和检索速度较快，平均时间复杂度为对数时间 O(log n)
> 
> - 元素不可重复，重复元素的添加操作将被忽略
> 
> - <mark>不允许使用 **``null``** 元素</mark>

### 6.3.4 LinkHashSet

> `LinkedHashSet`继承`HashSet`，底层使用`LinkedHashMap`保存所有元素
> 
> - 内部使用哈希表和链表实现，具有插入顺序的特性
> - 通过维护一个链表来记录元素的插入顺序
> - 具有HashSet的查找效率和LinkedHashMap的有序性
> - 时间复杂度：插入、删除、查找操作的平均时间复杂度为常数时间 O(1)。

### 6.3.5 对比

| 特性     | HashSet        | TreeSet      | LinkedHashSet |
|:------:|:--------------:|:------------:|:-------------:|
| 存储顺序   | 无序             | 有序（升序或自定义排序） | 有序（元素插入顺序）    |
| 线程安全   |                |              |               |
| 存储结构   | 哈希表            | 红黑树          | 哈希表           |
| 允许null | <mark>是</mark> | 否            | 是             |

## 6.4 Map

> `Map`用于存储键值对，提供了一组操作来管理键值对的存储和检索

### 6.4.1 常用方法

1. put(key, value) : 将指定的键值对添加到`Map`中，若键已经存在，则会用新的值替换旧的值，并返回旧的值（如果有）
2. get(key) : 返回与指定键相关联的值。如果键不存在，则返回`null`
3. getOrDefault(Object key, V defaultValue) ：用于获取指定键对应的值。如果键存在于 `Map` 中，则返回对应的值；如果键不存在，则返回指定的默认值
4. containsKey(key) : 检查`Map`中是否包含指定的键
5. containsValue(value) : 检查`Map`中是否包含指定的值
6. remove(key) : 从`Map`中移除指定键及其关联的值，并返回该值（如果存在）
7. size() : 返回`Map`中键值对的数量
8. isEmpty() ： 检查`Map`是否为空
9. keySet() : 返回一个包含`Map`中所有键的集合
10. values() : 返回一个包含`Map`中所有值的集合
11. entrySet() : 返回一个包含`Map`中所有键值对（`Map.Entry`对象）的集合

### 6.4.1 HashMap

> `HashMap`根据键的`hashCode`值存储数据，访问速度快，但遍历顺序不确定，<mark>允许最多一个null键，允许多条记录的值为null</mark>。HashMap<mark>非线程安全</mark>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致

### 6.4.2 LinkHashMap

> `LinkedHashMap`是基于哈希表和双向链表实现的，保留了键值对的插入顺序，性能介于`HashMap`和`TreeMap`之间

1. **保留插入顺序**：`LinkedHashMap`会记住元素的插入顺序，并按照该顺序进行迭代。这使得在遍历时可以按照插入的顺序访问元素

2. **基于哈希表的实现**：`LinkedHashMap`底层使用了哈希表来实现键值对的存储和检索。哈希表提供了快速的查找和插入操作，使得`LinkedHashMap`具有较高的性能

3. **允许空键值**：`LinkedHashMap`允许使用空键和空值

4. **可指定访问顺序**：除了保留插入顺序，`LinkedHashMap`还提供了一种按照访问顺序迭代的方式。通过构造函数或`accessOrder`参数的设置，可以将`LinkedHashMap`配置为按照访问顺序进行迭代，其中最近访问的元素将排在最后

### 6.4.3 ConcurrentHashMap

> `ConcurrentHashMap`继承自`AbstractMap`类，实现了`ConcurrentMap`接口，提供了一种线程安全的哈希表实现，是在多线程环境下使用的一种高效的并发容器

1. **线程安全性**：`ConcurrentHashMap`使用一种细粒度的锁机制来保证线程安全。它将哈希表分割成多个段（segments），每个段都可以独立地加锁。这样，多个线程可以同时访问不同的段，从而提高了并发性能

2. **高效性能**：`ConcurrentHashMap`在并发环境下提供了良好的性能。由于采用了细粒度的锁机制，不同的线程可以同时读取和修改不同的段，从而减少了竞争和锁的争用

3. **可伸缩性**：`ConcurrentHashMap`的设计允许在多核系统上进行扩展。每个段都可以独立地进行操作，因此在多线程环境下，各个线程可以并发地进行读取和写入操作，从而提高了整体的吞吐量

4. **迭代器支持**：`ConcurrentHashMap`的迭代器支持弱一致性（weakly consistent）。这意味着在迭代过程中，迭代器可能会反映出一些更新的结果，但不保证迭代器反映出最新的状态

5. **允许空键值**：ConcurrentHashMap不允许使用空键和空值

### 6.4.4 TreeMap

> `TreeMap`实现`SortedMap`接口，基于红黑树实现有序的映射，提供了按键的自然顺序或自定义顺序进行排序的功能

1. **有序性**：`TreeMap`中的键值对是按照键的自然顺序或自定义比较器的顺序进行排序的。这使得在遍历`TreeMap`时，键值对是按照排序顺序进行迭代的

2. **基于红黑树**：`TreeMap`使用红黑树这种自平衡的二叉搜索树数据结构来存储键值对。红黑树的特性保证了插入、删除和查找操作的时间复杂度都是O(log n)，因此`TreeMap`具有较高的性能

3. **允许空键**：与`HashMap`和`LinkedHashMap`类似，`TreeMap`<mark>允许空键，但不允许空值</mark>

4. **支持自定义比较器**：除了使用键的自然顺序进行排序，`TreeMap`还支持通过自定义比较器来指定排序规则。通过在构造函数中传入`Comparator`对象，可以实现根据自定义规则进行排序

### 6.4.5 HashTable

> `HashTable`实现了`Map`接口，提供了键值对的存储和检索功能

- **哈希表**：`HashTable`使用哈希表作为底层数据结构来存储键值对。它通过将键映射到哈希码，然后将哈希码映射到数组索引来实现快速的插入、删除和查找操作。在哈希表中，每个键值对被存储在一个桶（bucket）中，通过哈希码可以快速定位到对应的桶。

- **同步**：`HashTable`是线程安全的，它的方法都使用`synchronized`关键字进行同步，可以在多线程环境中安全地使用。这使得`HashTable`适用于并发访问的场景。

- **不允许空键和空值**：`HashTable`<mark>不允许使用空键</mark>（null key）和空值（null value）。如果尝试插入空键或空值，将会抛出`NullPointerException`。

- **性能**：由于`HashTable`在插入、删除和查找操作上都需要进行同步，因此在多线程环境下的性能可能较低。相对于`HashMap`和`ConcurrentHashMap`等其他类，`HashTable`的性能可能相对较差

### 6.6.6 对比

| 类名                | 数据结构     | 线程安全 | 键排序 | 插入顺序保持 | 空键空值 |
|:-----------------:|:--------:|:----:|:---:|:------:|:----:|
| HashTable         | 哈希表      | 是    | 否   | 否      | 否    |
| TreeMap           | 红黑树      | 否    | 是   | 否      | 是    |
| LinkedHashMap     | 哈希表 + 链表 | 否    | 否   | 是      | 是    |
| ConcurrentHashMap | 哈希表      | 是    | 否   | 否      | 否    |
| HashMap           | 哈希表      | 否    | 否   | 否      | 是    |

# 7 多线程编程

> 多线程是指同时执行多个线程的机制，可以让程序同时执行多个任务，提高程序的并发性和响应性

## 7.1 线程创建

### 7.1.1 继承Thread类

> 1. 继承`Thread`类，重写`run()`方法，定义线程的执行逻辑
> 
> 2. 创建该类的实例，调用`start()`方法启动线程

```java
class MyThread extends Thread {  
    public void run() {  
        // 线程的执行逻辑  
    }  
}  

// 创建线程并启动  
MyThread thread = new MyThread();  
thread.start();  
```

### 7.1.2 实现Runnable接口

> 1. 创建`Runnable`接口的实现类，实现`run()`方法
> 
> 2. 创建该类的实例，将其作为参数传递给`Thread`类的构造函数
> 
> 3. 调用`Thread`实例的`start()`方法启动线程

```java
class MyRunnable implements Runnable {  
    public void run() {  
        // 线程的执行逻辑  
    }  
}  

// 创建线程并启动  
MyRunnable runnable = new MyRunnable();  
Thread thread = new Thread(runnable);  
thread.start();  
```

### 7.1.3 实现Callable接口

> 1. 创建`Callable`接口的实现类，并实现`call()`方法
> 
> 2. 创建线程池，通过`submit()`方法提交`Callable`任务，返回`Future`对象
> 
> 3. 通过`Future`对象 `get()` 方法获取线程的执行结果

```java
import java.util.concurrent.Callable;  
import java.util.concurrent.ExecutorService;  
import java.util.concurrent.Executors;  
import java.util.concurrent.Future;  

class MyCallable implements Callable<T> {  
    public T call() throws Exception {  
        // 线程的执行逻辑  
    }  
}  

// 创建线程池  
ExecutorService executor = Executors.newSingleThreadExecutor();  

// 提交Callable任务并获取Future对象  
Future<Integer> future = executor.submit(new MyCallable());  

// 获取线程的执行结果  
int result = future.get();  

// 关闭线程池  
executor.shutdown();  
```

### 7.1.4 使用线程池

> 通过`Executors`类的静态方法可以创建不同类型的线程池，使用线程池管理和复用线程资源，提高线程的执行效率。线程池提供了两种方式来提交任务并执行
> 
> 1. `execute()`：用于提交`Runnable`任务给线程池执行，无返回值
> 2. `submit()`：提交`Callable`或`Runnable`任务给线程池执行并返回`Future`对象

```java
import java.util.concurrent.ExecutorService;  
import java.util.concurrent.Executors;  

class MyRunnable implements Runnable {  
    public void run() {  
        // 线程的执行逻辑  
    }  
}  

// 创建线程池  
ExecutorService executor = Executors.newFixedThreadPool(5);  

// 提交Runnable任务  
executor.submit(new MyRunnable());  

// 关闭线程池  
executor.shutdown();  
```

## 7.2 线程生命周期

1. **新建（New）**
   
   创建`Thread`对象时，线程处于新建状态

2. **就绪（Runnable）**
   
   线程调用`start()`方法后，进入就绪状态。就绪状态中，线程等待系统调度器分配CPU资源

3. **运行（Running）**
   
   当线程获得CPU执行时间时，进入运行状态，开始执行`run()`方法中的代码

4. **阻塞（Blocked）**
   
   在运行状态中，如果线程遇到某些阻塞的情况，例如等待I/O操作、等待获取锁、等待其他线程完成等，线程会进入阻塞状态。在阻塞状态下，线程不会占用CPU资源

5. **等待（Waiting）**
   
   线程在等待某个特定条件的情况下，可以进入等待状态。等待状态可以通过调用`wait()`方法、`join()`方法或`LockSupport.park()`方法来实现

6. **超时等待（Timed Waiting）**
   
   线程在等待一段指定的时间内，可以进入超时等待状态。超时等待状态可以通过调用`sleep()`方法、`wait(timeout)`方法、`join(timeout)`方法或`LockSupport.parkNanos()`方法实现

7. **终止（Terminated）**
   
   线程的运行结束后，进入终止状态，线程可以通过正常执行完`run()`方法或抛出未捕获的异常而终止

## 7.3 线程终止

### 7.3.1 正常结束

> 线程的`run()`方法执行完毕，线程自动终止

### 7.3.2 标志位

> 在线程代码中设置标志位，当标志位为`false`时，退出循环终止线程

```java
volatile boolean flag = true;  

public void run() {  
    while (flag) {  
        // 线程执行的任务  
    }  
}  

public void stopThread() {  
    flag = false;  
}  
```

### 7.3.3 interrupt()

> 调用线程的`interrupt()`方法来中断线程

```java
public void run() {  
    while (!Thread.currentThread().isInterrupted()) {  
        // 线程执行的任务  
    }  
}  

public void stopThread() {  
    Thread.currentThread().interrupt();  
}  
```

### 7.3.4 stop()

`Thread`类的`stop()`方法可立即强制终止线程，但可能导致线程持有的资源没有被正确释放，不会执行线程的清理操作，引发线程安全问题

```java
public void run() {  
    while (true) {  
        // 线程执行的任务  
    }  
}  

public void stopThread() {  
    Thread.currentThread().stop();  
}  
```

## 7. 4 线程上下文切换

> 线程的上下文切换是指在多线程环境下，CPU从一个线程切换到另一个线程执行的过程。线程的上下文包括线程的寄存器状态、栈指针、程序计数器等信息。当多个线程并发执行时，操作系统的调度器会分配CPU时间片给每个线程，每个线程在自己的时间片内执行。当一个线程的时间片用完或发生阻塞事件（如等待I/O操作完成）时，操作系统会进行线程切换，切换到另一个就绪的线程继续执行。线程上下文切换的过程包括保存当前线程的上下文信息和加载下一个线程的上下文信息。这个切换过程需要一定的开销，包括保存和恢复寄存器状态、切换内核栈、更新调度器数据结构等。因此，在高并发的情况下，频繁的线程上下文切换可能会导致系统性能下降。为了减少线程上下文切换的开销，可以采取以下策略：

1. 减少线程数量：合理控制创建的线程数量，避免不必要的线程竞争和上下文切换
2. 使用线程池：使用线程池管理线程，可以复用线程对象，减少线程创建和销毁的开销
3. 减少阻塞操作：避免在线程中频繁进行阻塞操作，如I/O操作，可以使用异步IO或非阻塞IO来减少线程的等待时间
4. 使用更高效的同步机制：选择合适的同步机制，如使用无锁数据结构、使用更轻量级的锁（如`java.util.concurrent`包中的锁）等，减少线程的竞争和阻塞
5. 使用并发集合：使用Java中的并发集合（如`ConcurrentHashMap`、`ConcurrentLinkedQueue`等）来替代传统的同步集合，减少对全局锁的竞争

## 7.5 线程调度算法

> 线程调度是指操作系统或Java虚拟机（JVM）对线程的调度和分配CPU时间片的过程。线程调度决定了每个线程在什么时候执行以及执行多长时间。Java中的线程调度是由操作系统的调度器和JVM的线程调度器共同完成的。操作系统的调度器负责将CPU时间片分配给不同的进程和线程，而JVM的线程调度器负责将CPU时间片分配给Java中的线程。Java中的线程调度器使用抢占式调度策略，即线程可以被强制中断并切换到其他线程

### 7.5.1 抢占式调度

> 在抢占式调度中，操作系统或运行时环境具有完全控制权，可以强制中断当前正在执行的线程，并将处理器时间分配给其他线程。抢占式调度允许高优先级线程优先执行，而低优先级线程可能会被延迟执行。这种调度策略能够提供更好的响应性和实时性，但也可能导致线程之间的竞争和不确定性

### 7.5.2 协同式调度

> 在协同式调度中，线程自愿放弃处理器时间，将控制权交给其他线程。线程执行期间不会被强制中断，而是通过显式的合作机制来进行线程切换。协同式调度要求线程之间具有良好的合作性，以确保每个线程适时释放处理器时间。这种调度策略可以提供更可预测和确定性的线程行为，但如果某个线程长时间不释放处理器时间，可能会导致其他线程无法执行

### 7.5.3 线程调度算法

#### 7.5.3.1 先来先服务调度（First-Come, First-Served Scheduling）

> 先来先服务调度算法是一种非抢占式调度算法，按照线程到达的顺序进行调度。当一个线程开始执行时，它将一直执行直到完成或被阻塞，但可能导致长作业优先问题，即长时间运行的线程会阻塞后续到达的线程

#### 7.5.3.2 最短作业优先调度（Shortest Job Next Scheduling）

> 最短作业优先调度算法是一种非抢占式调度算法，选择下一个执行的线程时，优先选择估计运行时间最短的线程，可以最大限度地减少平均等待时间，但需要事先知道每个线程的运行时间

#### 7.5.3.3 最高响应比优先（Highest Response Ratio Next Scheduling）

> 最高响应比优先算法是一种非抢占式调度算法，它综合考虑了等待时间和服务时间来选择下一个执行的线程。每个线程的响应比定义为（等待时间 + 服务时间）/ 服务时间。选择具有最高响应比的线程来执行，可以在一定程度上解决长作业优先问题

#### 7.5.3.4 多级反馈队列调度（Multilevel Feedback Queue Scheduling）

> 多级反馈队列调度算法将线程划分为多个优先级队列，并为每个队列分配不同的时间片大小。线程开始时进入最高优先级队列，如果在时间片内完成，则不会降低优先级。如果没有完成，线程将降低优先级并进入下一个队列。这种算法可以在长时间运行的线程和短时间运行的线程之间取得平衡

#### 7.5.3.5 最短进程优先调度（Shortest Process Next Scheduling）

> 最短进程优先调度算法是一种非抢占式调度算法，根据进程的估计执行时间来选择下一个执行的线程。与最短作业优先调度算法类似，但最短进程优先调度算法针对进程而不是线程

#### 7.5.3.6 最高优先级（Highest Priority Scheduling）

> 最高优先级算法是一种非抢占式或抢占式调度算法，为每个线程分配一个优先级，并在每个时间片内选择具有最高优先级的线程来执行。这种算法可以根据线程的重要性和紧迫性进行调度，但可能导致低优先级线程饥饿问题，即低优先级线程无法获得执行机会

#### 7.5.3.7 最短剩余时间优先调度（Shortest Remaining Time First Scheduling）

> 最短剩余时间优先调度算法是一种抢占式调度算法，在每个时间片内选择剩余执行时间最短的线程来执行。当一个新线程到达时，如果其剩余执行时间比当前正在执行的线程更短，那么当前线程将被抢占。这种算法可以最大限度地减少短作业的等待时间

#### 7.5.3.8 轮转法（Round-Robin Scheduling）

> 轮转法是一种抢占式调度算法，将处理器时间划分为固定大小的时间片，每个线程按照时间片轮流执行。如果一个线程在时间片结束之前没有完成，它将被暂停并等待下一次调度。轮转法可以提供公平的调度，但可能导致上下文切换开销增加

#### 7.5.3.9 基于时间片的轮转法（Time-Slice Round-Robin Scheduling）

> 基于时间片的轮转法是轮转法的一种变体，它为每个线程分配固定大小的时间片，并在时间片用完之前不会抢占线程。当一个线程的时间片用完时，它将被放到就绪队列的末尾，而不是立即被抢占。这种调度算法可以提供更好的响应时间，并减少上下文切换的频率

#### 7.5.3.10 基于优先级的轮转法（Priority-Based Round-Robin Scheduling）

> 基于优先级的轮转法是轮转法的一种变体，它根据线程的优先级进行调度。每个线程被分配一个优先级，并按照优先级顺序执行。当一个线程的时间片用完时，它将被放到就绪队列的末尾，而不会抢占其他线程。这种调度算法可以根据线程的重要性和紧迫性进行调度

### 7.5.4 线程调度算法对比

| 调度算法       | 类型           | 特点                                                                                                               |
|:----------:|:------------:|:---------------------------------------------------------------------------------------------------------------- |
| 先来先服务调度    | 非抢占式调度       | 按照任务到达的顺序进行调度，先到先服务。适用于长作业时间的任务，但可能导致短作业等待时间增加（短作业效应）                                                            |
| 最短作业优先调度   | 非抢占式调度       | 选择估计执行时间最短的任务进行调度，以减少平均等待时间。适用于短作业时间的任务，但可能导致长作业等待时间增加                                                           |
| 最高响应比优先    | 非抢占式调度       | 根据任务的等待时间和执行时间的比值选择下一个执行任务，以提高系统的响应性。避免了长作业的饥饿问题，但可能导致短作业等待时间增加                                                  |
| 多级反馈队列调度   | 非抢占式调度       | 将任务划分为多个优先级队列，每个队列有不同的时间片大小。任务开始时进入最高优先级队列，如果在时间片内完成，不降低优先级；否则，降低优先级并进入下一个队列。平衡长作业和短作业之间的调度                      |
| 最短进程优先调度   | 非抢占式调度       | 根据进程的估计执行时间选择下一个执行任务。类似于最短作业优先调度算法，但针对进程而不是线程                                                                    |
| 最高优先级      | 抢占式或非抢占式调度算法 | 为每个任务分配优先级，选择具有最高优先级的任务执行。抢占式最高优先级算法可以中断当前执行的任务，而非抢占式最高优先级算法等待当前任务完成后再执行下一个任务。可以根据任务的重要性和紧迫性进行调度，但可能导致低优先级任务饥饿问题 |
| 最短剩余时间优先调度 | 抢占式调度        | 在最短作业优先调度算法的基础上，动态地根据任务的剩余执行时间进行调度。如果有新任务到达并且其剩余时间比当前执行任务更短，则进行切换。适用于动态变化的任务执行时间，可以更快地响应短任务                      |
| 轮转法        | 抢占式调度        | 将处理器时间划分为固定大小的时间片，每个任务按顺序执行一个时间片。如果任务在时间片结束前未完成，暂停并等待下一次调度。提供公平的调度，但可能增加上下文切换开销                                  |
| 基于时间片的轮转法  | 轮转法的变体       | 为每个任务分配固定大小的时间片，在时间片用完之前不抢占任务。时间片用完后，任务被放到就绪队列的末尾。提供更好的响应时间，减少上下文切换频率                                            |
| 基于优先级的轮转法  | 轮转法的变体       | 根据任务的优先级进行调度。每个任务有一个优先级，按照优先级顺序执行。时间片用完后，任务被放到就绪队列的末尾，不抢占其他任务。根据任务的重要性和紧迫性进行调度                                   |

## 7.6 线程数据共享

1. 共享变量
   
   多个线程可以访问和修改同一个共享变量。为了确保线程安全，需要使用同步机制（如锁、互斥量）来保护共享变量的访问，以避免竞态条件（Race Condition）和数据不一致的问题

2. 线程安全的数据结构
   
   Java中提供了一些线程安全的数据结构，如`ConcurrentHashMap`、`CopyOnWriteArrayList`等。这些数据结构内部实现了线程安全的访问和修改操作，可以直接在多线程环境中使用

3. 使用锁机制
   
   通过使用锁（如`synchronized`关键字、`ReentrantLock`等）来控制对共享数据的访问。线程在访问共享数据之前需要获取锁，并在使用完共享数据后释放锁，确保同一时间只有一个线程可以访问共享数据

4. 使用线程安全的库函数
   
   一些库函数（如`AtomicInteger`、`AtomicReference`等）提供了原子操作，可以在不使用显式锁的情况下实现线程安全的数据访问和修改。

5. 使用线程安全的设计模式
   
   一些设计模式（如生产者-消费者模式、读写锁模式等）可以帮助实现线程之间的数据共享和同步

## 7.7 线程池

>  线程池是一种用于管理和复用线程的机制，可以避免频繁创建和销毁线程，减少线程创建的时间和系统资源的消耗，提高多线程应用程序的性能和效率

### 7.7.1 线程池的组成

> 1. **任务队列（Task Queue）**
>    
>    用于存储待执行的任务，可以是有界队列或无界队列
> 
> 2. **线程池管理器（ThreadPool Manager）**
>    
>    用于创建和管理线程池的组件，提供线程池的创建、销毁、扩容等操作
> 
> 3. **工作线程（Worker Threads）**
>    
>    线程池中的线程，用于执行任务
> 
> 4. **线程池接口（Thread Pool Interface）**
>    
>    定义线程池的基本操作，如提交任务、关闭线程池等，提供对线程池管理和控制的方法

### 7.7.2 线程池工作过程

> 1. 初始化线程池，包括创建线程池对象、初始化任务队列和线程管理器等
> 
> 2. 当有任务需要执行时，可以通过线程池接口将任务提交给线程池
> 
> 3. 线程池根据需要从任务队列中获取任务，并将任务分配给空闲的工作线程
> 
> 4. 工作线程执行任务，并在任务执行完成后返回线程池
> 
> 5. 线程池继续接收和处理新的任务，直到收到关闭线程池的指令

### 7.7.3 常见线程池

#### 7.7.3.1 固定大小线程池（FixedThreadPool）

> `FixedThreadPool`是固定大小线程池，线程数量是预先指定的

```java
ExecutorService executorService = Executors.newFixedThreadPool(5);
```

#### 7.7.3.2 缓存线程池（CachedThreadPool）

> `CachedThreadPool`根据需要自动调整线程数量，当有新任务提交时，如果有空闲线程，则立即使用；如果没有空闲线程，则创建新线程

```java
ExecutorService executorService = Executors.newCachedThreadPool();
```

#### 7.7.3.3 单线程池（SingleThreadPool）

> `SingleThreadPool`只有一个工作线程

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
```

#### 7.7.3.4 定时任务线程池（ScheduledThreadPool）

> `ScheduledThreadPool`用于执行定时任务，可以按照固定的频率或延迟执行任务

```java
ScheduledExecutorService executorService = Executors.newScheduledThreadPool(5);
```

### 7.7.4 线程池参数

## 7.8 多线程常用方法

#### 7.8.1 start()

> `start()`方法用于启动线程，并执行线程的`run()`方法

```java
Thread thread = new Thread(new MyRunnable());
thread.start();
```

#### 7.8.2 run()

> `run()`方法定义线程的任务逻辑，需要在自定义的`Runnable`或`Thread`类中重写该方法。线程启动后会自动调用`run()`方法来执行线程的任务逻辑

```java
class MyRunnable implements Runnable {
 @Override
 public void run() {
 // 线程的任务逻辑
 }
}
```

#### 7.8.3 sleep()

> `sleep()`方法使当前线程暂停执行指定的时间，以毫秒为单位，可以用于在代码中引入暂停，以便让其他线程有机会执行

```java
try {
 Thread.sleep(1000); // 暂停1秒
} catch (InterruptedException e) {
 e.printStackTrace();
}
```

#### 7.8.4 join()

> `join()`方法使当前线程等待另一个线程执行完毕，然后再继续执行。当调用某个线程的`join()`方法时，当前线程将会阻塞，直到被调用的线程执行完毕

```java
Thread thread = new Thread(new MyRunnable());
thread.start();
try {
 thread.join(); // 等待thread线程执行完毕
} catch (InterruptedException e) {
 e.printStackTrace();
}
```

#### 7.8.5 yield()

> `yield()`方法让出当前线程的执行权，使得其他具有相同优先级的线程有机会执行。调用`yield()`方法后，当前线程会进入就绪状态，让系统重新调度线程

```java
Thread.yield();
```

#### 7.8.6 interrupt()

> `interrupt()`方法中断当前线程，即设置线程的中断标志位为`true`。调用`interrupt()`方法并不会立即停止线程的执行，而是通过检查线程的中断状态来决定是否停止执行

```java
Thread.currentThread().interrupt();
```

#### 7.8.7 isInterrupted()

> `isInterrupted()`方法用于检查当前线程的中断状态

```java
if (Thread.currentThread().isInterrupted()) {
 // 线程被中断的处理逻辑
}
```

#### 7.8.9 wait()

> `wait()`方法使当前线程进入等待状态，直到其他线程调用对象的`notify()`或`notifyAll()`方法来唤醒等待的线程。`wait()`方法必须在同步块或同步方法中调用

```java
class SharedObject {
 public synchronized void doWait() throws InterruptedException {
 wait(); // 线程等待
 }
}
```

#### 7.8.10 notify() / notifyAll()

> `notify()`方法用于唤醒等待的线程，`notifyAll()`方法用于唤醒所有等待的线程。这两个方法必须在同步块或同步方法中调用

```java
class SharedObject {
 public synchronized void doNotify() {
 notify(); // 唤醒等待的线程
 }
 public synchronized void doNotifyAll() {
 notifyAll(); // 唤醒所有等待的线程
 }
}
```

#### 7.8.11 submit

> 使用线程池的`submit()`方法来提交任务，可以接受`Runnable`或`Callable`类型的任务。`submit()`方法会返回一个`Future`对象，可以用于获取任务的执行结果

```java
executor.submit(new Runnable() {
 public void run() {
 // 任务的执行逻辑
 }
});
executor.submit(new Callable<Integer>() {
 public Integer call() throws Exception {
 // 任务的执行逻辑，可以返回执行结果
 return 42;
 }
});
```

#### 7.8.12 shutdownNow()

> `shutdownNow()`方法用于关闭线程池。调用`shutdownNow()`方法后，线程池将尝试停止所有正在执行的任务，并且不再接受新的任务

```java
executor.shutdownNow();
```

#### 7.8.13 awaitTermination()

> `awaitTermination()`方法用于等待线程池中的任务执行完毕，或超过指定的等待时间。可以在调用`shutdown()`方法后，再调用`awaitTermination()`方法来等待线程池中的任务完成

#### 7.8.14 execute(Runnable command)

> `execute()`方法用于提交一个`Runnable`任务给线程池执行，不返回执行结果

```java
executor.execute(new Runnable() {
 public void run() {
 // 任务的执行逻辑
 }
}); 
```

# 8 反射（Reflection）

> <mark>反射是指在运行时动态地获取类的信息并操作类或对象的机制</mark>。通过反射，可以在运行时获取类的构造函数、方法、字段等信息，并且可以动态地创建对象、调用方法、访问字段等。反射也可以绕过Java的访问控制机制，因此在使用反射时要注意安全性和合理性

## 8.1 反射的应用场合

1. 框架和库开发：通过反射，框架可以在运行时加载、实例化和调用用户提供的类和方法，以实现动态的功能扩展和配置
2. 序列化和反序列化：反射可以动态地获取类的信息并创建对象，以便正确地进行序列化和反序列化操作
3. 单元测试和调试：在单元测试和调试过程中，反射可以帮助我们访问和调用私有方法、字段和构造函数，以便进行更全面的测试和调试
4. 动态代理：反射可以用于实现动态代理（Dynamic Proxy）模式，其中代理对象在运行时动态地创建并代理对目标对象的方法调用
5. 动态配置和扩展：反射实现动态配置和扩展的功能。通过读取配置文件或其他外部资源中的类名和方法名等信息，可以在运行时使用反射加载和调用这些类和方法，实现动态的配置和扩展能力

## 8.2 Java反射API

### 8.2.1 java.lang.Class

- `getName()`：获取类的全限定名称

- `getSuperclass()`：获取类的父类

- `getInterfaces()`：获取类实现的接口

- `getConstructors()`：获取类的所有公共构造函数

- `getMethods()`：获取类的所有公共方法

- `getFields()`：获取类的所有公共字段

- `Class.forName("ClassName")`：通过类的全限定名称获取类的运行时信息

- `Class.getDeclaredFields()`：获取类的所有字段（包括私有字段）

- `Class.getField("fieldName")`：获取指定名称的字段信息

- `Class.getMethod("methodName", parameterTypes)`：获取指定名称和参数类型的方法信息

- `Class.getDeclaredMethods()`：获取类的所有方法（包括私有方法）

- `Class.getAnnotation(Annotation.class)`：获取类的注解

### 8.2.2 java.lang.reflect.Constructor

- `newInstance(Object... args)`：使用构造函数创建类的对象

### 8.2.3 java.lang.reflect.Method

- `invoke(Object obj, Object... args)`：调用方法

- `Method.setAccessible(true)`：设置方法可访问

- `Method.getGenericReturnType()`：获取方法的泛型返回类型

- `Method.getGenericParameterTypes()`：获取方法的泛型参数类型

- `Method.getAnnotation(Annotation.class)`：获取方法的注解

### 8.2.4 java.lang.reflect.Field

- `get(Object obj)`：获取字段的值

- `set(Object obj, Object value)`：设置字段的值

- `Field.setAccessible(true)`：设置字段可访问

- `Field.getGenericType()`：获取字段的泛型类型

- `Field.getAnnotation(Annotation.class)`：获取字段的注解

### 8.2.5 java.lang.reflect.Modifier

- `Modifier.isPublic(int modifiers)`：判断修饰符是否为public

- `Modifier.isPrivate(int modifiers)`：判断修饰符是否为private

- `Modifier.isProtected(int modifiers)`：判断修饰符是否为protected

- `Modifier.isStatic(int modifiers)`：判断修饰符是否为static

- `Modifier.isFinal(int modifiers)`：判断修饰符是否为final

## 8.3 获取Class对象

### 8.3.1 class 属性

> 使用`.class`语法直接获取类的`Class`对象

```java
Class<String> stringClass = String.class;
```

### 8.3.2 getClass()

> 使用对象的`getClass()`方法获取其对应的`Class`对象

```java
Person person = new Person();
Class<? extends Person> personClass = person.getClass();
```

### 8.3.3 Class.forName()

> 使用`Class.forName("ClassName")`方法获取类的`Class`对象，"ClassName"是要获取的类的全限定名称

```java
Class<?> personClass = Class.forName("com.example.Person");
```

## 8.4 创建对象

### 8.4.1 Class对象newInstance()方法（已过时）

> 这种方式适用于类具有无参构造函数的情况。`newInstance()`方法会调用类的默认构造函数来创建对象

```java
Class<?> clazz = MyClass.class;
Object obj = clazz.newInstance();
```

### 8.4.2 Constructor对象newInstance()方法

> 这种方式适用于类具有参数化构造函数的情况。首先，通过`getConstructor()`方法获取到所需的构造函数对象，可以根据构造函数的参数类型来选择合适的`getConstructor()`方法。然后，使用构造函数对象的`newInstance()`方法来创建对象

```java
Class<?> clazz = MyClass.class;
Constructor<?> constructor = clazz.getConstructor();
Object obj = constructor.newInstance();
```

# 9 IO（Input/Output）

> `IO`是`Java`编程语言中用于处理输入和输出的标准库，提供了一套丰富的类和接口，用于读取和写入数据，包括文件、网络连接、内存缓冲等

## 9.1 IO流分类

> 根据数据的单位和处理方式，IO流主要分为字节流、字符流、输入流、输出流

### 9.1.1 字节流（Byte Streams）

> 字节流以字节为单位进行输入和输出，适用于处理二进制数据或者无需进行字符编码转换的场景

### 9.1.2 字符流（Character Streams）

> 字符流用于以字符为单位进行输入和输出操作，在处理文本数据时会进行字符编码转换，可以方便地处理各种字符集和国际化文本

### 9.1.3 输入流（Input Streams）

> 输入流用于从数据源（如文件、网络连接等）中读取数据。输入流以字节为单位进行读取操作，适用于读取二进制数据或未经过字符编码的文本数据

### 9.1.4 输出流（Output Stream）

> 输入流用于从数据源读取数据的抽象概念。它提供了一种逐个字节（byte）读取数据的方式，适用于读取二进制数据或未经过字符编码的文本数据

## 9.2 常用IO流

### 9.2.1 FileInputStream

> `FileInputStream`继承自`InputStream`类，是<mark>字节输入流</mark>，可以读取文件中的字节数据

- `int read()`：从输入流中读取一个字节的数据，并返回读取的字节值（0-255），到达流的末尾返回-1
- `int read(byte[] buffer)`：从输入流中读取一定数量的字节数据，并存储到指定的字节数组`buffer`中。返回实际读取的字节数，如果到达流的末尾，返回-1
- `void close()`：关闭输入流，释放与之关联的系统资源

### 9.2.2 FileOutputStream

> FileOutputStream继承自`OutputStream`类，是<mark>字节输出流</mark>，可以写入字节数据到文件中

- `void write(int b)`：将指定的字节写入输出流
- `void write(byte[] buffer)`：将指定的字节数组中的数据写入输出流
- `void close()`：关闭输出流，释放与之关联的系统资源

### 9.2.3 BufferedInputStream

> `BufferedInputStream`继承`FilterInputStream`类，是用于从输入流中读取数据的缓冲输入流，可以包装其他输入流并提供了缓冲功能以减少对底层输入流的实际读取次数，提高读取文件数据的效率

- `int read()`：从缓冲输入流中读取一个字节的数据，并返回读取的字节值（0-255），到达流的末尾，返回-1
- `int read(byte[] buffer)`：从缓冲输入流中读取一定数量的字节数据，并存储到指定的字节数组`buffer`中。返回实际读取的字节数，如果到达流的末尾，返回-1
- `void close()`：关闭缓冲输入流，释放与之关联的系统资源

### 9.2.4 BufferedOutputStream

> `BufferedOutputStream`继承`FilterOutputStream`类，是用于向输出流中写入数据的缓冲输出流，可以包装其他输出流，并提供了缓冲功能以减少对底层输出流的实际写入次数，提高写入文件数据的效率

- `void write(int b)`：将指定的字节写入缓冲输出流
- `void write(byte[] buffer)`：将指定的字节数组中的数据写入缓冲输出流
- `void flush()`：刷新缓冲输出流，将缓冲区中的数据立即写入到底层输出流中
- `void close()`：关闭缓冲输出流，释放与之关联的系统资源。在关闭之前，会先调用`flush()`方法刷新缓冲区

### 9.2.5 ObjectInputStream

> `ObjectInputStream`继承`InputStream`类，是用于从输入流中读取对象的对象输入流，可以包装其他输入流并提供了读取对象的方法，支持对象的序列化和反序列化，要读取和写入的对象必须是可序列化的

- `Object readObject()`：从对象输入流中读取一个对象，并返回读取的对象。需要注意的是，读取的对象必须是经过序列化的
- `void close()`：关闭对象输入流，释放与之关联的系统资源

### 9.2.6 ObjectOutputStream

> `ObjectOutputStream`继承`OutputStream`类，是用于向输出流中写入对象的对象输出流，可以包装其他输出流并提供了写入对象的方法

- `void writeObject(Object obj)`：将指定的对象写入对象输出流。需要注意的是，写入的对象必须是可序列化的
- `void flush()`：刷新对象输出流，将缓冲区中的数据立即写入到底层输出流中
- `void close()`：关闭对象输出流，释放与之关联的系统资源。在关闭之前，会先调用`flush()`方法刷新缓冲区

### 9.2.7 FileReader

> `FileReader`继承`Reader`类，是用于从文件中读取字符数据的字符输入流，可以读取文本文件中的字符数据

- `int read()`：读取单个字符并返回其ASCII码值，到达文件末尾则返回-1
- `int read(char[] cbuf)`：将字符读入数组，并返回读取的字符数，到达文件末尾则返回-1
- `void close()`：关闭字符输入流，释放与之关联的系统资源

### 9.2.8 FileWriter

> `FileWriter`继承`Writer`类，是用于向文件中写入字符数据的字符输出流，可以向文本文件中写入字符数据

- `void write(int c)`：写入单个字符
- `void write(char[] cbuf)`：将字符数组的内容写入文件
- `void write(String str)`：写入字符串
- `void flush()`：刷新字符输出流，将缓冲区中的数据立即写入到底层输出流中
- `void close()`：关闭字符输出流，释放与之关联的系统资源。在关闭之前，会先调用`flush()`方法刷新缓冲区

### 9.2.9 BufferedReader

> `BufferedReader`继承`Reader`类，是用于从字符输入流中读取文本数据的缓冲字符输入流，通过添加缓冲区来减少对底层流的直接访问次数，提高读取性能

- `String readLine()`：读取一行文本数据并返回，到达文件末尾则返回`null`
- `int read(char[] cbuf, int off, int len)`：将字符读入数组的指定位置，并返回读取的字符数
- `void close()`：关闭字符输入流，释放与之关联的系统资源

### 9.2.10 BufferedWriter

> `BufferedWriter`继承`Writer`类，是用于向字符输出流中写入文本数据的缓冲字符输出流，通过添加缓冲区来减少对底层流的直接访问次数，提高写入性能

- `void write(String str)`：写入字符串
- `void write(char[] cbuf, int off, int len)`：将字符数组的指定部分写入文件
- `void newLine()`：写入一个平台特定的换行符
- `void flush()`：刷新字符输出流，将缓冲区中的数据立即写入到底层输出流中
- `void close()`：关闭字符输出流，释放与之关联的系统资源。在关闭之前，会先调用`flush()`方法刷新缓冲区

### 9.2.11 InputStreamReader

> `InputStreamReader`继承`Reader`类，是将字节输入流转换为字符输入流的桥接类，通过指定字符集来将字节流转换为字符流

- `InputStreamReader(InputStream in)`：使用平台默认字符集将字节输入流转换为字符输入流
- `InputStreamReader(InputStream in, String charsetName)`：使用指定的字符集将字节输入流转换为字符输入流
- `int read()`：读取单个字符并返回其Unicode值
- `int read(char[] cbuf, int off, int len)`：将字符读入数组的指定位置，并返回读取的字符数
- `void close()`：关闭字符输入流

### 9.2.12 OutputStreamWriter

> `OutputStreamWriter`继承`Writer`类，是将字符输出流转换为字节输出流的桥接类，通过指定字符集将字符流转换为字节流

- `OutputStreamWriter(OutputStream out)`：使用平台默认字符集将字符输出流转换为字节输出流
- `OutputStreamWriter(OutputStream out, String charsetName)`：使用指定的字符集将字符输出流转换为字节输出流
- `void write(int c)`：将指定字符写入文件
- `void write(char[] cbuf, int off, int len)`：将字符数组的指定部分写入文件
- `void flush()`：刷新字符输出流，将缓冲区中的数据立即写入到底层输出流中
- `void close()`：关闭字符输出流

# 10 其他概念

## 10.1 内部类（Inner Class）

> 内部类是定义在其他类内部的类。内部类可以访问包含它的外部类的成员，包括私有成员，并且可以提供更好的封装性和代码组织结构 

### 10.1.1 成员内部类（Member Inner Class）

> 成员内部类定义在外部类的成员位置（字段、方法或构造函数），但不是在任何方法内部，可以访问外部类的所有成员，包括私有成员。成员内部类的实例化需要依赖于外部类的实例

```java
public class OuterClass {  
    private int outerData;  

    public class InnerClass {  
        public void innerMethod() {  
            outerData = 10; // 访问外部类的成员变量  
            outerMethod(); // 访问外部类的方法  
        }  
    }  

    public void outerMethod() {  
        // ...  
    }  
}  
```

### 10.1.2 静态内部类（Static Inner Class）

> 静态内部类是定义在外部类内部但被声明为静态的类，不依赖于外部类的实例，可以直接通过外部类名访问。静态内部类只能访问外部类的静态成员

```java
public class OuterClass {  
    private static int outerData;  

    public static class InnerClass {  
        public void innerMethod() {  
            outerData = 10; // 访问外部类的静态成员  
            outerMethod(); // 访问外部类的静态方法  
        }  
    }  

    public static void outerMethod() {  
        // ...  
    }  
}  
```

### 10.1.3 方法内部类（Local Inner Class）

> 方法内部类定义在方法内部，只能在方法内部被实例化和使用，且不能使用访问控制修饰符（如`public`、`private`等）修饰

```java
public class OuterClass {  
    public void outerMethod() {  
        class LocalInnerClass {  
            public void innerMethod() {  
                // ...  
            }  
        }  

        LocalInnerClass innerObj = new LocalInnerClass();  
        innerObj.innerMethod();  
    }  
}  
```

### 10.1.4 匿名内部类（Anonymous Inner Class）

> 匿名内部类没有显式定义类的名称，直接创建一个类的实例，通常用于实现接口或继承抽象类，并覆盖其方法

```java
public class OuterClass {  
    public void outerMethod() {  
        Runnable runnable = new Runnable() {  
            @Override  
            public void run() {  
                // ...  
            }  
        };  

        Thread thread = new Thread(runnable);  
        thread.start();  
    }  
}  
```

## 10.2 序列化（Serialization）/ 反序列化（Deserialization）

> 1. 序列化是指将对象转换为字节流的过程，以便在网络上传输或将其保存到文件中，默认情况下，所有的非静态成员变量都会被序列化
> 
> 2. 反序列化是将字节流重新转换为对象的过程

### 10.2.1 序列化版本号

> 序列化的对象在进行版本控制时需要注意如果对类进行了更改，可能会导致反序列化失败或数据不一致的问题。可以使用`serialVersionUID`来显式指定序列化版本号，并在进行更改时进行适当的更新

### 10.2.2 实现序列化

> 当一个类实现了`Serializable`接口时，表明该类的实例可以被序列化和反序列，如果需要自定义序列化和反序列化过程，可以实现 `Serializable` 接口，并在类中定义自定义的 `writeObject` 和 `readObject` 方法来控制序列化和反序列化的行为

```java
import java.io.Serializable;
public class MyClass implements Serializable {
 // 类的成员和方法
 // ...
}
```

### 10.2.3 阻止序列化

> 1. 实现`java.io.Serializable`接口的类默认是可序列化的。如果不想让某个类可序列化，可以在类的定义中添加`transient`关键字来标记不希望被序列化的字段。被标记为`transient`的字段在序列化过程中将被忽略
> 
> 2. 如果想完全禁止某个类的对象序列化，可以在类中实现Serializable接口并在其中重写readObject()和writeObject()方法，可以对序列化和反序列化过程进行自定义控制

```java
private void writeObject(java.io.ObjectOutputStream out) throws IOException {
throw new IOException("禁止序列化"); // 在尝试对该类的对象进行序列化或反序列化时，会抛出`IOException`，从而阻止序列化操作。
}
private void readObject(java.io.ObjectInputStream in) throws IOException {
throw new IOException("禁止反序列化");
}
```

> 3. 如果希望禁止整个Java应用程序的对象序列化，可以使用Java安全管理器（SecurityManager）。通过自定义安全策略禁止`SerializablePermission`权限，阻止所有类的对象序列化

```java
import java.io.SerializablePermission;
public class NoSerializationSecurityManager extends SecurityManager {
@Override
public void checkPermission(java.security.Permission perm) {
if (perm instanceof SerializablePermission) {
throw new SecurityException("禁止序列化");
}
}
}
```

然后，在你的应用程序中，可以通过以下方式来设置自定义的安全管理器：

```java
System.setSecurityManager(new NoSerializationSecurityManager());
```

这样一来，任何尝试进行对象序列化的操作都会抛出`SecurityException`

## 10.3 复制

> 复制指创建对象的副本，以便在不改变原始对象的情况下对其进行操作或传递给其他部分使用

### 10.3.1 直接赋值复制

> 直接赋值复制是将对象的引用赋值给另一个对象，使得它们指向同一个内存地址，当一个对象发生改变时，另一个对象也会受到影响

```java
class Person {
 private String name;

public Person(String name) {
 this.name = name;
 }

public void setName(String name) {
 this.name = name;
 }

public String getName() {
 return name;
 }
}
public class Main {
 public static void main(String[] args) {
 Person person1 = new Person("John");
 Person person2 = person1; // 直接赋值复制
 System.out.println(person1.getName()); // 输出 "John"
 System.out.println(person2.getName()); // 输出 "John"

 person1.setName("Alice");

 System.out.println(person1.getName()); // 输出 "Alice"
 System.out.println(person2.getName()); // 输出 "Alice"
 }
}
```

### 10.3.2 浅复制（Shallow Copy）

> 浅复制复制了对象的引用，而不是对象本身。如果原始对象发生改变，复制对象也会受到影响

### 10.3.3 深复制（Deep Copy）

> 深复制创建了新的对象，并且该对象的字段也被复制了一份，确保了原始对象和复制对象之间的独立性，即使一个对象发生改变，另一个对象也不会受到影响

#### 10.3.3.1 使用对象的拷贝构造函数或克隆方法

> 要求对象实现`Cloneable`接口并重写`clone()`方法，调用`clone()`方法创建对象的深复制，确保在复制过程中所有的引用类型字段也进行深复制

```java
class Person implements Cloneable {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

public class Main {
    public static void main(String[] args) {
        try {
            Person person1 = new Person("John");
            Person person2 = (Person) person1.clone(); // 深复制

            System.out.println(person1.getName()); // 输出: John
            System.out.println(person2.getName()); // 输出: John

            person2.setName("Alice");

            System.out.println(person1.getName()); // 输出: John
            System.out.println(person2.getName()); // 输出: Alice
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
```

#### 10.3.3.2 使用序列化和反序列化

> 通过将对象写入字节流并从字节流中读取对象，可以实现对象的深复制，要求对象及其引用类型字段都必须实现`Serializable`接口

```java
class Person implements Serializable {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person1 = new Person("John");
        Person person2 = deepCopy(person1); // 深复制

        System.out.println(person1.getName()); // 输出: John
        System.out.println(person2.getName()); // 输出: John

        person2.setName("Alice");

        System.out.println(person1.getName()); // 输出: John
        System.out.println(person2.getName()); // 输出: Alice
    }

    public static <T extends Serializable> T deepCopy(T object) {
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);

            ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
            ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
            return (T) objectInputStream.readObject();
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

## 10.4 锁

> 锁是一种用于控制并发访问共享资源的机制，可以确保在同一时间只有一个线程可以访问被锁定的代码块或资源，从而保证线程安全性

### 10.4.1 Synchronized 同步锁

> `synchronized`用于修饰方法或代码块，确保在同一时刻只有一个线程可以执行被同步的代码，保证线程安全
> 
> 1. `synchronized`锁是隐式锁，当线程进入被`synchronized`修饰的方法或代码块时，会自动获取锁，并在执行完毕后释放锁
> 
> 2. `synchronized`锁是<mark>可重入</mark>的，同一个线程可以多次获取同一个锁
> 
> 3. `synchronized`锁是<mark>非公平</mark>锁，不能保证等待时间最长的线程优先获取锁

#### 10.4.1.1 同步方法

> 使用`synchronized`修饰方法，可以将整个方法体作为同步代码块，确保同一时刻只有一个线程执行该方法

```java
public synchronized void synchronizedMethod() {
    // 同步代码块
}
```

#### 10.4.1.2 同步代码块

> 使用`synchronized`修饰代码块，可以将指定的代码块作为同步代码块，只有获取到锁的线程才能执行该代码块

```java
public void someMethod() {  
    // 非同步代码 (Non-synchronized code)  
    synchronized (lockObject) {  
        // 同步代码块 (Synchronized code block)  
    }  
    // 非同步代码 (Non-synchronized code)  
}  
```

#### 10.4.1.3 锁对象

> 当线程执行`synchronized` 块时会尝试获取该块中指定锁对象的锁。只有线程获得锁对象的锁才可以执行 `synchronized` 块中的代码，而其他线程则被阻塞，直到锁被释放。锁对象的作用是确保在同一时刻只有一个线程可以进入 `synchronized`块，保证线程安全性和数据一致性
> 
> 1. 锁对象的粒度：若锁对象的粒度太大，可能会导致线程间的竞争增加，降低并发性能。若锁对象的粒度太小，可能会导致频繁的锁竞争和线程上下文切换
> 
> 2. 锁对象的共享性：锁对象应该是多个线程之间共享的对象。如果每个线程都使用自己的锁对象，那么线程间的同步就无法实现。可以使用共享的实例对象或类对象作为锁对象，或者创建专门的共享对象作为锁对象
> 
> 3. 锁对象的可见性：为了确保多个线程之间对锁对象的可见性，应使用 `volatile` 或者 `final` 修饰锁对象，确保当一个线程修改锁对象时，其他线程能够立即看到最新的值

```java
public class Counter {  
    private int count;  
    private Object lock = new Object();  

    public void increment() {  
        synchronized (lock) {  
            count++;  
        }  
    }  

    public int getCount() {  
        synchronized (lock) {  
            return count;  
        }  
    }  
}  
```

### 10.4.2 ReentrantLock 可重入锁

> `ReentrantLock` 作为一种显式锁提供了更灵活的锁定机制，可以通过`lock()`方法获取锁，并通过`unlock()`方法释放锁

1. **可重入性（Reentrancy）**：`ReentrantLock` 支持可重入性，也就是同一个线程可以多次获得同一个锁。如果一个线程已经获得了锁，再次请求该锁时，不会被阻塞，而是继续执行，可以避免死锁，简化编程模型

2. **公平性（Fairness）**：`ReentrantLock` 可以设置为公平锁或非公平锁。公平锁会按照线程请求锁的顺序来获取锁，而非公平锁则允许插队，可能会导致某些线程长时间等待

3. **条件变量（Condition）**：`ReentrantLock` 提供了 `Condition` 接口的实现，可以通过 `newCondition()` 方法创建一个与锁关联的条件变量。条件变量可以用于在多线程之间进行等待和通知，更灵活地控制线程的执行顺序

4. **可中断锁（Interruptible Lock）**：`ReentrantLock` 提供了可中断的获取锁的方式。在等待锁的过程中，如果其他线程中断了当前线程，当前线程可以选择放弃获取锁而返回，可以避免线程长时间等待锁而无法响应中断的问题

5. **性能优化**：`ReentrantLock` 使用了一些底层技术，如 CAS（Compare and Swap）操作，来提高并发性能，在高并发场景下具有更好的性能

```java
public class ReentrantLockExample {  
    private ReentrantLock lock = new ReentrantLock();  

    public void outerMethod() {  
        lock.lock(); // 获取锁  
        try {  
            System.out.println("Outer method acquired the lock");  
            innerMethod(); // 调用内部方法  
        } finally {  
            lock.unlock(); // 释放锁  
            System.out.println("Outer method released the lock");  
        }  
    }  

    public void innerMethod() {  
        lock.lock(); // 获取同一个锁  
        try {  
            System.out.println("Inner method acquired the lock");  
            // 执行一些操作  
        } finally {  
            lock.unlock(); // 释放锁  
            System.out.println("Inner method released the lock");  
        }  
    }  

    public static void main(String[] args) {  
        ReentrantLockExample example = new ReentrantLockExample();  
        example.outerMethod();  
    }  
}  
```

### 10.4.3 ReadWriteLock 读写锁

> `ReadWriteLock`同步机制用于多线程环境下对共享资源进行读写操作，允许多个线程同时读取共享资源，但只允许一个线程进行写操作，可以提高并发性能，适用于读操作频繁而写操作较少的场景

1. `readLock()`：获取读锁。读锁可以被多个线程共享，读取共享资源，提高并发性能

2. `writeLock()`：获取写锁。写锁只能被一个线程独占，用于写入共享资源

3. 读写互斥：当进行写操作时，同一时刻其他线程的读操作会被阻塞；当进行读操作时，同一时刻所有线程的写操作会被阻塞

```java
import java.util.concurrent.locks.ReadWriteLock;  
import java.util.concurrent.locks.ReentrantReadWriteLock;  

public class ReadWriteLockExample {  
    private final ReadWriteLock lock = new ReentrantReadWriteLock();  
    private int sharedData = 0;  

    public int readData() {  
        lock.readLock().lock(); // 获取读锁  
        try {  
            // 读取共享数据  
            return sharedData;  
        } finally {  
            lock.readLock().unlock(); // 释放读锁  
        }  
    }  

    public void writeData(int newData) {  
        lock.writeLock().lock(); // 获取写锁  
        try {  
            // 写入共享数据  
            sharedData = newData;  
        } finally {  
            lock.writeLock().unlock(); // 释放写锁  
        }  
    }  
}  
```

### 10.4.4 StampedLock 锁

> `StampedLock` 位于 `java.util.concurrent.locks`包中，提供了三种锁模式：读锁、写锁和乐观读锁
> 
> - StampedLock是<mark>非重入锁</mark>，同一个线程多次获取同一个锁会导致死锁
> 
> - 乐观读锁是一种无锁状态，允许其他线程进行写操作，但在读取数据时需要验证是否被修改，乐观读锁可以通过调用`tryOptimisticRead()`方法获取，并通过调用`validate()`方法验证数据是否被修改

1. `acquire()`: 当线程需要访问共享资源时，调用`acquire()`方法来获取信号量。如果当前信号量的许可数大于0，线程将继续执行。否则，线程将被阻塞，直到有可用的许可

2. `release()`: 当线程使用完共享资源后，应该调用`release()`方法释放信号量的许可，以便其他线程可以获取许可并访问资源

## 10.5 线程同步机制

### 10.5.1 同步机制分类

> 1. **互斥同步**：使用互斥锁（Synchronized、ReentrantLock）确保共享资源在任意时刻只能被一个线程访问，来实现线程同步
> 
> 2. **读写同步**：使用读写锁（ReadWriteLock）来允许多个线程同时读取共享资源，但在写操作时需要互斥访问，以提高并发性能
> 
> 3. **条件同步**：使用条件变量（`wait()`、`notify()`、`notifyAll()`）来实现线程的等待和唤醒操作以及条件的判断，线程在满足特定条件时才能继续执行，否则需要等待
> 
> 4. **信号量同步**：使用信号量来控制同时访问共享资源的线程数量，限制并发访问的线程数目，控制多个线程对共享资源的访问
> 
> 5. **原子同步**：使用原子类（AtomicInteger、AtomicReference）来实现原子操作，避免多线程竞争导致的数据不一致性

### 10.5.2  信号量（Semaphore）

> `Semaphore` 类位于`java.util.concurrent`包中，是一种线程同步机制，用于控制对共享资源的访问。`Semaphore` 维护了一个许可证（permit）的数量，线程需要获取许可证才能继续执行，而许可证的数量会随着线程的获取和释放而增加或减少，因此可以限制同时访问某个资源的线程数量

1. `acquire()`：获取一个许可证，许可证数量不足则线程会阻塞等待

2. `acquire(int permits)`：获取指定数量的许可证，许可证数量不足则线程会阻塞等待

3. `release()`：释放一个许可证，将其返回给信号量

4. `release(int permits)`：释放指定数量的许可证，将其返回给信号量

5. `availablePermits()`：获取当前可用的许可证数量

6. `tryAcquire()`：获取一个许可证，成功获取返回true，否则返回false，不会阻塞线程

7. `tryAcquire(int permits)`：获取指定数量的许可证，成功获取返回true，否则返回false，不会阻塞线程

```java
import java.util.concurrent.Semaphore;  

public class SemaphoreExample {  
    private static final int MAX_CONCURRENT_THREADS = 5;  
    private static final Semaphore semaphore = new Semaphore(MAX_CONCURRENT_THREADS);  

    public static void main(String[] args) {  
        for (int i = 0; i < 10; i++) {  
            Thread thread = new Thread(new Task());  
            thread.start();  
        }  
    }  

    static class Task implements Runnable {  
        @Override  
        public void run() {  
            try {  
                semaphore.acquire(); // 获取许可证  
                System.out.println("Thread " + Thread.currentThread().getId() + " acquired a permit.");  
                // 执行对共享资源的操作  
                Thread.sleep(1000);  
                semaphore.release(); // 释放许可证  
                System.out.println("Thread " + Thread.currentThread().getId() + " released a permit.");  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
}  
```

### 10.5.3 AtomicInteger 原子类

> `AtomicInteger` 原子类位于 `java.util.concurrent.atomic` 包中，是用于实现原子操作的整数类型，提供原子操作来确保对整数值的操作是线程安全的

1. `get()`：获取当前的整数值

2. `set(int newValue)`：设置新的整数值

3. `getAndSet(int newValue)`：设置新的整数值，并返回旧的值

4. `compareAndSet(int expect, int update)`：如果当前值等于预期值 `expect`，则将值更新为 `update`，并返回更新是否成功

5. `getAndIncrement()`：先获取当前值，然后将值加一

6. `getAndDecrement()`：先获取当前值，然后将值减一

7. `incrementAndGet()`：先将值加一，然后获取新的值

8. `decrementAndGet()`：先将值减一，然后获取新的值

9. `getAndAdd(int delta)`：先获取当前值，然后将值增加指定的增量 `delta`

10. `addAndGet(int delta)`：先将值增加指定的增量 `delta`，然后获取新的值

```java
import java.util.concurrent.atomic.AtomicInteger;  

public class AtomicIntegerExample {  
    private static AtomicInteger counter = new AtomicInteger(0);  

    public static void main(String[] args) {  
        // 创建并启动10个线程  
        for (int i = 0; i < 10; i++) {  
            Thread thread = new Thread(new Worker());  
            thread.start();  
        }  
    }  

    static class Worker implements Runnable {  
        @Override  
        public void run() {  
            // 执行一些操作  
            for (int i = 0; i < 1000; i++) {  
                // 使用incrementAndGet()方法原子地增加计数器的值  
                counter.incrementAndGet();  
            }  
        }  
    }  
}  
```

## 10.6 函数式接口

## 10.7 lambda表达式

# 11 常用API

## 11.1 Scanner

1. `next()`：读取输入的下一个单词（以空格分隔）
   
   ```java
   import java.util.Scanner; // 导入 Scanner 库
   
   Scanner scanner = new Scanner(System.in);
   String word = scanner.next();
   System.out.println("输入的单词是：" + word);
   ```

2. `nextInt()`：读取输入的下一个整数
   
   ```java
   Scanner scanner = new Scanner(System.in);
   int number = scanner.nextInt();
   System.out.println("输入的整数是：" + number);
   ```

3. `nextLine()`：读取输入的下一行文本
   
   ```java
   Scanner scanner = new Scanner(System.in);
   String line = scanner.nextLine();
   System.out.println("输入的文本是：" + line);
   ```

4. `hasNext()`：检查是否还有输入可读取
   
   ```java
   Scanner scanner = new Scanner(System.in);
   if (scanner.hasNextInt()) {
       System.out.println("输入的整数是：" + scanner.nextInt());
   } else {
       System.out.println("输入的不是整数。");
   }
   ```

## 11.2 Integer

1. `Integer.parseInt(String s)`：字符串转整型
   
   ```java
   int num = Integer.parseInt("123"); // 将字符串 "123" 解析为整数 123
   ```

2. `Integer.parseInt(String s, int radix)`：将字符串按指定的基数解析为整数值
   
   ```java
   String str = "FF";
   int num = Integer.parseInt(str, 16); // 将字符串 "FF" 解析为十六进制的整数 255
   ```

3. `Integer.toString(int i)`：整数转字符串
   
   ```java
   String str = Integer.toString(123); // 将整数 123 转换为字符串 "123"
   ```

4. `Integer.valueOf(int i)`：返回一个表示指定整数值的 `Integer` 实例
   
   ```java
   Integer integerObj = Integer.valueOf(123); // 返回表示整数 123 的 Integer 对象
   ```

5. `intValue()`： `Integer` 对象转 `int`
   
   ```java
   Integer integerObj = Integer.valueOf(123);
   int num = integerObj.intValue(); // 将 Integer 对象转换为 int
   ```

6. `Integer.compareTo(int num1, int num2)`：比较两个整数的大小。返回值为负数、零或正数，表示当前整数小于、等于或大于另一个整数
   
   ```java
   int result = Integer.compare(123, 456); // 返回 -1，表示 num1 小于 num2
   ```

7. `Integer.bitCount(int i)`：返回指定整数的二进制表示中的1的个数
   
   ```java
   int count = Integer.bitCount(123); // 返回整数 123 的二进制表示中的1的个数
   ```

8. `Integer.reverse(int i)`：将指定整数的二进制位进行反转
   
   ```java
   int num = 123;
   int reversed = Integer.reverse(num); // 返回整数 123 的二进制位反转后的结果
   ```

9. `Integer.toHexString(int i)`：将整数转换为十六进制表示的字符串
   
   ```java
   String hex = Integer.toHexString(123); // 将整数 123 转换为十六进制字符串 "7B"
   ```

10. `Integer.toBinaryString(int i)`：将整数转换为二进制表示的字符串
    
    ```java
    String binary = Integer.toBinaryString(123); // 将整数 123 转换为二进制字符串 "1111011"
    ```

11. `Integer.MAX_VALUE` 和 `Integer.MIN_VALUE`：分别表示 `int` 类型的最大值和最小值
    
    ```java
    int maxValue = Integer.MAX_VALUE; // 最大值为 2147483647
    int minValue = Integer.MIN_VALUE; // 最小值为 -2147483648
    ```

## 11.3 Character

1. `Character.isLetter(char ch)`: 判断字符是否为字母。
   
   ```java
   boolean isLetter = Character.isLetter('A');
   ```

2. `Character.isDigit(char ch)`: 判断字符是否为数字
   
   ```java
   boolean isDigit = Character.isDigit('7');
   ```

3. `Character.isLetterOrDigit(char ch)`: 判断字符是否为字母或数字
   
   ```java
   boolean isLetterOrDigit = Character.isLetterOrDigit('5');
   ```

4. `Character.isWhitespace(char ch)`: 判断字符是否为空白字符
   
   ```java
   boolean isWhitespace = Character.isWhitespace(' ');
   ```

5. `Character.isLowerCase(char ch)`: 判断字符是否为小写字母
   
   ```java
   boolean isLowerCase = Character.isLowerCase('a');
   ```

6. `Character.isUpperCase(char ch)`: 判断字符是否为大写字母
   
   ```java
   boolean isUpperCase = Character.isUpperCase('B');
   ```

7. `Character.toUpperCase(char ch)`: 将字符转换为大写
   
   ```java
   char uppercase = Character.toUpperCase('h');
   ```

8. `Character.toLowerCase(char ch)`: 将字符转换为小写
   
   ```java
   char lowercase = Character.toLowerCase('H');
   ```

9. `Character.getNumericValue(char ch)`: 获取字符的数值
   
   ```java
   int numericValue = Character.getNumericValue('9');
   ```

## 11.4 Collections

1. `Collections.sort(List<T> list)`: 对列表进行升序排序
   
   ```java
   List<Integer> numbers = new ArrayList<>();
   Collections.sort(numbers);
   ```

2. `Collections.reverse(List<T> list)`: 反转列表中的元素顺序
   
   ```java
   Collections.reverse(numbers);
   ```

3. `Collections.shuffle(List<T> list)`: 随机打乱列表中的元素顺序
   
   ```java
   Collections.shuffle(numbers);
   ```

4. `Collections.binarySearch(List<? extends Comparable<? super T>> list, T key)`: 在有序列表中使用二分查找找到指定元素的索引
   
   ```java
   List<Integer> numbers = new ArrayList<>();
   numbers.add(2);
   numbers.add(5);
   numbers.add(8);
   int index = Collections.binarySearch(numbers, 5);
   ```

5. `Collections.max(Collection<? extends T> coll)`: 返回集合中的最大元素
   
   ```java
   Integer max = Collections.max(numbers);
   ```

6. `Collections.min(Collection<? extends T> coll)`: 返回集合中的最小元素
   
   ```java
   Integer min = Collections.min(numbers);
   ```

7. `Collections.frequency(Collection<?> coll, Object obj)`: 返回集合中指定元素的出现次数
   
   ```java
   List<String> words = new ArrayList<>();
   words.add("apple");
   words.add("banana");
   words.add("apple");
   int frequency = Collections.frequency(words, "apple");
   ```

8. `Collections.addAll(Collection<? super T> c, T... elements)`: 将指定的元素添加到集合中
   
   ```java
   List<String> fruits = new ArrayList<>();
   Collections.addAll(fruits, "apple", "banana", "orange");
   ```

9. `Collections.fill(List<? super T> list, T obj)`: 使用指定的元素填充列表
   
   ```java
   List<Integer> numbers = new ArrayList<>(Collections.nCopies(5, 0));
   Collections.fill(numbers, 10);
   ```

10. `Collections.unmodifiableList(List<? extends T> list)`: 创建一个不可修改的列表
    
    ```java
    List<String> names = new ArrayList<>();
    names.add("Alice");
    names.add("Bob");
    List<String> unmodifiableNames = Collections.unmodifiableList(names);
    ```

## 11.5 Arrays

1. `Arrays.sort(array)`：对数组进行升序排序
   
   ```java
   int[] array = {5, 2, 8, 1, 4};
   Arrays.sort(array); // 数组变为 {1, 2, 4, 5, 8}
   ```

2. `Arrays.sort(array, fromIndex, toIndex)`：指定排序范围
   
   ```java
   Arrays.sort(array, 1, 4); // 数组变为 {5, 1, 2, 8, 4}
   ```

3. `Arrays.binarySearch(array, key)`：在已排序的数组中使用二分查找算法查找指定元素的索引。如果找到，返回索引；未找到返回负数
   
   ```java
   int index = Arrays.binarySearch(array, 4); // index为2
   ```

4. `Arrays.copyOf(original, newLength)`：将原始数组的指定长度部分复制到一个新数组中，若新长度大于原始数组长度，则用默认值填充
   
   ```java
   int[] original = {1, 2, 3};
   int[] newArray = Arrays.copyOf(original, 5); // newArray为 {1, 2, 3, 0, 0}
   ```

5. `Arrays.toString(array)`：将数组转换为字符串形式
   
   ```java
   String arrayString = Arrays.toString(array); // arrayString为 "[1, 2, 3]"
   ```

6. `Arrays.equals(array1, array2)`：比较两个数组是否相等。相等的条件是两个数组长度相同，并且对应位置的元素也相同
   
   ```java
   int[] array1 = {1, 2, 3};
   int[] array2 = {1, 2, 3};
   boolean isEqual = Arrays.equals(array1, array2); // isEqual为 true
   ```

7. `Arrays.fill(array, value)`：将数组的所有元素都设置为指定的值
   
   ```java
   int[] array = new int[5];
   Arrays.fill(array, 9); // 数组变为 {9, 9, 9, 9, 9}
   ```

8. `Arrays.asList(array)`：将数组转换为List集合
   
   ```java
   String[] array = {"你好", "世界"};
   List<String> list = Arrays.asList(array); // list为 ["你好", "世界"]
   ```

## 11.6 ArrayList

1. `add()`：向 ArrayList 的末尾添加元素
   
   ```java
   ArrayList<String> list = new ArrayList<>();
   list.add("Apple");
   ```

2. `get()`：获取指定索引位置的元素
   
   ```java
   String fruit = list.get(0); // 获取第一个元素 "Apple"
   ```

3. `set()`：替换指定索引位置的元素
   
   ```java
   list.set(1, "Mango"); // 将索引为 1 的元素替换为 "Mango"
   ```

4. `remove()`：删除指定索引位置的元素
   
   ```java
   list.remove(2); // 删除索引为 2 的元素 "Orange"
   ```

5. `size()`：获取 ArrayList 的元素个数
   
   ```java
   int size = list.size(); // 获取 ArrayList 的大小，此处为 2
   ```

6. `isEmpty()`：检查 ArrayList 是否为空
   
   ```java
   boolean empty = list.isEmpty(); // 检查 ArrayList 是否为空，此处为 false
   ```

7. `contains()`：检查 ArrayList 是否包含指定元素
   
   ```java
   boolean contains = list.contains("Apple"); 
   ```

8. `indexOf()`：查找指定元素在 ArrayList 中的索引
   
   ```java
   int index = list.indexOf("Banana"); // 查找 "Banana" 在 ArrayList 中的索引，此处为 1
   ```

9. `clear()`：清空 ArrayList 中的所有元素
   
   ```java
   list.clear(); // 清空 ArrayList 中的所有元素
   ```

10. `toArray()`：将 ArrayList 转换为数组
    
    ```java
    String[] array = list.toArray(new String[0]); // 将 ArrayList 转换为数组
    ```

## 11.7 LinkedList

1. `add(element)`：将元素添加到链表的末尾

2. `addFirst(element)`：将元素添加到链表的开头

3. `addLast(element)`：将元素添加到链表的末尾

4. `offer(element)`：将元素添加到链表的末尾，并在链表已满时返回 `false`

5. `offerFirst(element)`：将元素添加到链表的开头，并在链表已满时返回 `false`

6. `offerLast(element)`：将元素添加到链表的末尾，并在链表已满时返回 `false`

7. `remove()`：移除并返回链表的第一个元素

8. `removeFirst()`：移除并返回链表的第一个元素

9. `removeLast()`：移除并返回链表的最后一个元素

10. `poll()`：移除并返回链表的第一个元素，并在链表为空时返回 `null`

11. `pollFirst()`：移除并返回链表的第一个元素，并在链表为空时返回 `null`

12. `pollLast()`：移除并返回链表的最后一个元素，并在链表为空时返回 `null`

13. `get(index)`：获取指定索引位置的元素

14. `getFirst()`：获取链表的第一个元素

15. `getLast()`：获取链表的最后一个元素

16. `peek()`：获取链表的第一个元素，并在链表为空时返回 `null`

17. `peekFirst()`：获取链表的第一个元素，并在链表为空时返回 `null`

18. `peekLast()`：获取链表的最后一个元素，并在链表为空时返回 `null`

19. `size()`：返回链表中元素的个数

20. `isEmpty()`：检查链表是否为空

21. `clear()`：清空链表中的所有元素

22. `contains(element)`：检查链表是否包含指定的元素

23. `indexOf(element)`：返回指定元素在链表中第一次出现的索引，如果不存在则返回 -1

24. `lastIndexOf(element)`：返回指定元素在链表中最后一次出现的索引，如果不存在则返回 -1

25. `toArray()`：将链表转换为数组

## 11.8 Stack

1. `push(E item)`：将元素压入栈顶

2. `peek()`：获取栈顶元素，但不移除它

3. `pop()`：移除并返回栈顶元素

4. `empty()`：检查栈是否为空

5. `size()`：返回栈中元素的个数

## 11.9 ArrayDeque

1. **添加元素**：
- `addFirst(E e)`：将元素添加到双端队列的开头
- `addLast(E e)`：将元素添加到双端队列的末尾
- `offerFirst(E e)`：将元素添加到双端队列的开头，并返回是否成功
- `offerLast(E e)`：将元素添加到双端队列的末尾，并返回是否成功

```java
Deque<String> deque = new ArrayDeque<>();
deque.addFirst("element1");
deque.addLast("element2");
boolean addedFirst = deque.offerFirst("element3");
boolean addedLast = deque.offerLast("element4");
```

2. **获取元素**：
- `getFirst()`：获取双端队列的开头元素，但不移除它
- `getLast()`：获取双端队列的末尾元素，但不移除它
- `peekFirst()`：获取双端队列的开头元素，但不移除它。如果队列为空，则返回null
- `peekLast()`：获取双端队列的末尾元素，但不移除它。如果队列为空，则返回null

```java
Deque<String> deque = new ArrayDeque<>();
deque.add("element1");
deque.add("element2");
String firstElement = deque.getFirst();
String lastElement = deque.getLast();
String peekedFirstElement = deque.peekFirst();
String peekedLastElement = deque.peekLast();
```

3. **移除元素**：
- `removeFirst()`：移除并返回双端队列的开头元素。
- `removeLast()`：移除并返回双端队列的末尾元素。
- `pollFirst()`：移除并返回双端队列的开头元素。如果队列为空，则返回null。
- `pollLast()`：移除并返回双端队列的末尾元素。如果队列为空，则返回null。

```java
Deque<String> deque = new ArrayDeque<>();
deque.add("element1");
deque.add("element2");
String removedFirstElement = deque.removeFirst();
String removedLastElement = deque.removeLast();
String polledFirstElement = deque.pollFirst();
String polledLastElement = deque.pollLast();
```

4. **其他操作**：
- `size()`：返回双端队列中的元素个数。
- `isEmpty()`：检查双端队列是否为空。
- `clear()`：清空双端队列中的所有元素。

```java
Deque<String> deque = new ArrayDeque<>();
deque.add("element1");
deque.add("element2");
int size = deque.size();
boolean empty = deque.isEmpty();
deque.clear();
```

## 11.10 HashSet

1. `add(E element)`: 将指定的元素添加到集合中
   
   ```java
   HashSet<String> set = new HashSet<>();
   set.add("apple");
   ```

2. `remove(Object element)`: 从集合中移除指定的元素
   
   ```java
   set.remove("apple");
   ```

3. `contains(Object element)`: 判断集合是否包含指定的元素
   
   ```java
   boolean contains = set.contains("apple");
   ```

4. `isEmpty()`: 判断集合是否为空
   
   ```java
   boolean isEmpty = set.isEmpty();
   ```

5. `size()`: 返回集合中元素的数量
   
   ```java
   int size = set.size();
   ```

6. `clear()`: 清空集合中的所有元素
   
   ```java
   HashSet<String> set = new HashSet<>();
   set.add("apple");
   set.clear();
   ```

7. `iterator()`: 返回一个迭代器，用于遍历集合中的元素
   
   ```java
   HashSet<String> set = new HashSet<>();  
   set.add("apple");  
   set.add("banana");  
   Iterator<String> iterator = set.iterator();  
   while (iterator.hasNext()) {  
       System.out.println(iterator.next()); // 打印元素  
   }  
   ```

## 11.11 HashMap

1. `put(K key, V value)`: 将指定的键值对添加到映射中
   
   ```java
   HashMap<String, Integer> map = new HashMap<>();
   map.put("apple", 1);
   ```

2. `V putOrDefault(K key, V value, V defaultValue) `: 将指定的键和值放入映射中，如果键已存在，则使用新值替换旧值。如果键不存在，该方法会返回默认值
   
   ```java
   map.put("apple", 1, 0);
   ```

3. `getOrDefault(Object key, V defaultValue)`: 根据键获取对应的值,允许我们指定一个默认值，以防止我们在获取键对应的值时遇到不存在的键。如果键不存在，我们可以使用默认值来代替
   
   ```java
   map.put("apple", 1);
   Integer value = map.getOrDefault("apple", 0);
   ```

4. `get(Object key)`: 根据键获取对应的值
   
   ```java
   map.put("apple", 1);
   Integer value = map.get("apple");
   ```

5. `remove(Object key)`: 根据键移除对应的键值对
   
   ```java
   map.put("apple", 1);
   map.remove("apple");
   ```

6. `containsKey(Object key)`: 判断映射中是否包含指定的键
   
   ```java
   map.put("apple", 1);
   boolean containsKey = map.containsKey("apple");
   ```

7. `containsValue(Object value)`: 判断映射中是否包含指定的值
   
   ```java
   map.put("apple", 1);
   boolean containsValue = map.containsValue(1);
   ```

8. `isEmpty()`: 判断映射是否为空
   
   ```java
   boolean isEmpty = map.isEmpty();
   ```

9. `size()`: 返回映射中键值对的数量
   
   ```java
   map.put("apple", 1);
   int size = map.size();
   ```

10. `clear()`: 清空映射中的所有键值对
    
    ```java
    map.put("apple", 1);
    map.clear();
    ```

11. `keySet()`: 返回映射中所有键的集合
    
    ```java
    map.put("apple", 1);
    Set<String> keys = map.keySet();
    ```

12. `values()`: 返回映射中所有值的集合
    
    ```java
    map.put("apple", 1);
    Collection<Integer> values = map.values();
    ```

## 11.12 String

1. `length()`：返回字符串的长度
   
   ```java
   String str = "你好，世界";
   int length = str.length(); // length为6
   ```

2. `charAt(index)`：返回指定索引位置的字符
   
   ```java
   String str = "你好，世界";
   char ch = str.charAt(2); // ch为'，'
   ```

3. `split(regex)`：根据正则表达式将字符串拆分为子字符串数组，返回数组
   
   ```java
   String str = "你好，世界，Java";
   String[] parts = str.split("，"); // parts为["你好", "世界", "Java"]
   ```

4. `substring(beginIndex)`：返回从指定索引开始到字符串末尾的子字符串
   
   ```java
   String str = "你好，世界";
   String substr = str.substring(2); // substr为"，世界"
   ```

5. `indexOf(str)`：返回指定字符串在原始字符串中第一次出现的索引位置
   
   ```java
   String str = "你好，世界";
   int index = str.indexOf("世界"); // index为3
   ```

6. `substring(beginIndex, endIndex)`：返回从指定的开始索引到结束索引之间的子字符串
   
   ```java
   String str = "你好，世界";
   String substr = str.substring(2, 4); // substr为"，世"
   ```

7. `concat(str)`：将指定字符串连接到原始字符串的末尾
   
   ```java
   String str = "你好";
   String result = str.concat("，世界"); // result为"你好，世界"
   ```

8. `lastIndexOf(str)`：返回指定字符串在原始字符串中最后一次出现的索引位置
   
   ```java
   String str = "你好，世界，你好";
   int lastIndex = str.lastIndexOf("你好"); // lastIndex为6
   ```

9. `startsWith(prefix)`：检查字符串是否以指定的前缀开头
   
   ```java
   String str = "你好，世界";
   boolean startsWithNiHao = str.startsWith("你好"); // startsWithNiHao为true
   ```

10. `endsWith(suffix)`：检查字符串是否以指定的后缀结尾
    
    ```java
    String str = "你好，世界";
    boolean endsWithShiJie = str.endsWith("世界"); // endsWithShiJie为true
    ```

11. `toLowerCase()`：将字符串转换为小写
    
    ```java
    String str = "Hello World";
    String lowercase = str.toLowerCase(); // lowercase为"hello world"
    ```

12. `toUpperCase()`：将字符串转换为大写
    
    ```java
    String str = "Hello World";
    String uppercase = str.toUpperCase(); // uppercase为"HELLO WORLD"
    ```

13. `trim()`：去除字符串<mark>两端</mark>的空白字符
    
    ```java
    String str = " 你好，世界 ";
    String trimmed = str.trim(); // trimmed为"你好，世界"
    ```

14. `replace(oldChar, newChar)`：将字符串中的所有旧字符替换为新字符
    
    ```java
    String str = "你好，世界";
    String replaced = str.replace('，', ','); // replaced为"你好,世界"
    ```

15. `replaceAll(regex, replacement)`：使用新字符串替换所有匹配正则表达式的子字符串
    
    ```java
    String str = "你好，世界！";
    String replaced = str.replaceAll("[！,]", ""); // replaced为"你好世界"
    ```

16. `toCharArray()` : 将字符串转换为字符数组，返回包含字符串中的每个字符的字符数组
    
    ```java
    String str = "Hello";
    char[] charArray = str.toCharArray();
    ```

## 11.13 StringBuilder

1. `append(str)`：将指定的字符串追加到当前字符串的末尾
   
   ```java
   StringBuilder sb = new StringBuilder("你好");
   sb.append("世界"); // 字符串变为 "你好世界"
   ```

2. `reverse()`：反转当前字符串
   
   ```java
   StringBuilder sb = new StringBuilder("你好世界");
   sb.reverse(); // 字符串变为 "界世好你"
   ```

3. `toString()`：将 `StringBuilder` 对象转换为 `String` 对象
   
   ```java
   StringBuilder sb = new StringBuilder("你好世界");
   String str = sb.toString(); // str为 "你好世界"
   ```

4. `insert(index, str)`：在指定的索引位置插入字符串
   
   ```java
   StringBuilder sb = new StringBuilder("你世");
   sb.insert(1, "好"); // 字符串变为 "你好世"
   ```

5. `delete(startIndex, endIndex)`：删除从开始索引到结束索引之间的字符
   
   ```java
   StringBuilder sb = new StringBuilder("你好世界");
   sb.delete(1, 3); // 字符串变为 "你界"
   ```

6. `deleteCharAt(index)`：删除指定索引位置的字符
   
   ```java
   StringBuilder sb = new StringBuilder("你好世界");
   sb.deleteCharAt(2); // 字符串变为 "你好界"
   ```

7. `replace(startIndex, endIndex, str)`：使用指定字符串替换从开始索引到结束索引之间的字符
   
   ```java
   StringBuilder sb = new StringBuilder("你好世界");
   sb.replace(1, 3, "abc"); // 字符串变为 "你abc界"
   ```

## 11.14 Iterator

# 12 问题

## 12.1 概念对比

### 12.1.1 面向对象与面向过程

> 面向对象是一种以对象为核心的编程范式，通过<mark>将数据和操作封装在对象中</mark>，使得代码更具可读性、可维护性和可扩展性。`Java`是面向对象的编程语言，面向对象是Java的核心特性之一。在`Java`中，一切皆为对象，类是对象的模板，对象是类的实例。
> 
> 1. **封装**：将数据和对数据的操作封装在类中，并通过访问修饰符控制对数据的访问，隐藏类的内部实现细节，同时提供对外部代码的安全访问接口
> 
> 2. **继承**：继承允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。继承通过关键字`extends`实现，子类使用`extends`关键字父类声明继承关系，子类可以继承父类的非私有成员变量和方法，并可以重写父类的方法
> 
> 3. **多态**：多态允许使用父类的引用来引用子类的对象，并根据实际引用的对象类型来调用相应的方法。多态性通过继承和方法重写实现的，当一个父类引用指向一个子类对象时，根据实际对象的类型来调用相应的方法

> 面向过程是一种以过程为核心的编程范式，其核心思想是将程序分解为一系列的过程或函数，每个过程都包含一系列的操作步骤。程序的执行是按照顺序逐步执行的，每个过程都是对问题的一部分进行处理。
> 
> 1. **以过程为中心**：程序的设计和组织以过程（函数）为基本单位，通过函数的调用和参数传递来完成任务
> 
> 2. **顺序执行**：程序按照顺序执行，逐步完成任务
> 
> 3. **数据和行为分离**：数据和对数据的操作分离，强调数据的处理和算法
> 
> 4. **全局数据共享**：数据在全局范围内共享，函数可以直接访问和修改全局数据

### 12.1.2 方法重写与方法重载

> - **方法重写**  ：在子类中定义一个与父类方法具有<mark>相同名称</mark>、<mark>相同参数列表</mark>和<mark>相同返回类型</mark>的方法，并且子类方法的访问修饰符不能比父类方法更严格，是<mark>运行时多态</mark>
> 
> - **方法重载** ：在同一个类中定义多个方法，具有<mark>相同名称</mark>但具有<mark>不同的参数列表</mark>（参数类型、参数个数或参数顺序不同），是<mark>编译时多态</mark>

### 12.1.3 深拷贝和浅拷贝

> **相同** ：用于创建对象副本，避免对象之间的相互影响

> 1. **拷贝内容** ： 浅拷贝复制对象本身和对象中的基本数据类型变量，深拷贝递归地复制对象本身和对象中的所有成员变量
> 
> 2. **对引用类型的影响** ：浅拷贝的新对象和原对象共享引用，修改其中一个对象的引用类型成员变量会影响另一个对象，深拷贝的新对象拥有独立引用，修改其中一个对象的引用类型成员变量不会影响另一个对象
> 
> 3. **性能** ：浅拷贝通常比深拷贝执行速度更快

### 12.1.4 值传递和引用传递

> **相同** ：用于将参数传递给函数或方法，在函数或方法内部使用传递的参数

> 1. **传递的内容** ：值传递是将参数的值传递给函数或方法，引用传递是将参数的引用（内存地址）传递给函数或方法
> 
> 2. **对基本数据类型的影响** ：值传递对于基本数据类型，<mark>传递的是值的副本</mark>，所以在函数或方法内部修改参数的值不会影响原始的值
> 
> 3. **对对象的影响** ：引用传递对于对象，<mark>传递的是对象的引用</mark>，所以在函数或方法内部修改对象的属性会直接影响原始对象

### 12.1.5 接口和抽象类

> **相同** ：都包含抽象方法，不能直接实例化，需要被其他类继承或实现

> 1. **继承关系** ：类可以实现多个接口，但是只能继承一个抽象类
> 
> 2. **内容** ：接口不允许包含非抽象方法或成员变量，抽象类可以包含非抽象方法和成员变量
> 
> 3. **设计目的** ：接口用于实现类之间的松耦合，使得类之间更容易互相替换和扩展。抽象类提供通用的基类，封装通用的行为和状态，便于子类继承和扩展

### 12.1.6 公平锁和非公平锁

> **相同** ：用于控制并发访问共享资源，确保在同一时间只有一个线程可以访问被锁定的代码块或资源，保证线程安全性

> 1. **获取锁的顺序** ：公平锁按照线程请求锁的顺序分配锁资源，先来先得。非公平锁没有顺序保证，线程在等待锁时，不管是否有其他线程在等待，它都有机会获取到锁资源
> 
> 2. **线程饥饿问题** ：公平锁按照请求顺序分配锁资源，可以避免线程饥饿问题，即某个线程长时间无法获取锁资源。非公平锁存在线程饥饿问题，因为某个线程可能会连续多次获得锁资源，导致其他线程一直无法获取锁
> 
> 3. **性能** ：公平锁的实现需要维护一个等待队列，以记录等待锁的线程，性能较低。非公平锁不需要维护等待队列，性能较好

### 12.1.7 乐观锁和悲观锁

> **相同** ：用于控制并发访问共享资源，确保在同一时间只有一个线程可以访问被锁定的代码块或资源，保证线程安全性

> 1. **基本假设**：乐观锁假设多个线程之间不会频繁发生冲突，不需要加锁限制访问；悲观锁假设多个线程之间会频繁发生冲突，需要加锁限制访问
> 2. **实现方式**：乐观锁总是乐观地假设最好的情况，每次去拿数据的时候都认为别人不会修改这个数据，所以不会上锁，只会要对数据进行更新时判断一下在此期间(拿到数据到更新的期间)别人有没有去更改这个数据，可以使用版本号机制和CAS算法实现。总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
> 3. **性能开销**：乐观锁在并发量较低时性能较好，因为不需要频繁地加锁和释放锁；而悲观锁在并发量较高时性能较好，因为可以确保数据的一致性

### 12.1.8 可重入锁和非可重入锁

> **相同** ：用于控制并发访问共享资源，确保在同一时间只有一个线程可以访问被锁定的代码块或资源，保证线程安全性

> 1. **可重入性**：可重入锁允许一个线程在持有锁的情况下再次获取该锁，不会出现死锁。非可重入锁不允许一个线程在持有锁的情况下再次获取该锁，会导致死锁
> 
> 2. **锁的持有**：可重入锁会跟踪锁的持有次数，每次加锁时会增加持有次数，每次释放锁时会减少持有次数。当持有次数为0时，锁才会完全释放。非可重入锁没有持有次数的概念，只有加锁和释放锁的操作

### 12.1.9 IO 和 NIO

> **相同** ：用于进行输入和输出操作的编程模型，用于读取和写入数据

> 1. **阻塞与非阻塞** ：IO是阻塞式的，当执行IO操作时，线程会被阻塞，直到操作完成才能继续执行后续代码。NIO是非阻塞式的，当执行NIO操作时，线程不会被阻塞，可以立即返回，继续执行其他操作。需要通过轮询方式（如Selector）来获取操作的结果
> 
> 2. **IO模型** ：IO使用流（Stream）模型，通过字节流和字符流来进行数据的读写操作。NIO使用通道（Channel）和缓冲区（Buffer）模型，通过通道（Channel）来进行数据的读写操作，数据通过缓冲区（Buffer）进行传输
> 
> 3. **事件驱动** ：NIO是事件驱动的，通过Selector来监听多个通道的事件，当有事件发生时，可以进行相应的处理。IO没有内置的事件驱动机制，需要通过多线程或线程池来处理多个IO操作
> 
> 4. **性能** ：NIO在处理大量连接时，使用较少的线程来处理请求，因此在性能上可能更高效。IO在每个连接上都需要一个独立的线程来处理请求，当连接数较多时，线程开销较大，可能导致性能下降

**Java传统I/O（IO）：**

- 基于字节流和字符流的概念，使用InputStream和OutputStream进行字节级别的读写，使用Reader和Writer进行字符级别的读写。
- IO操作是阻塞的，当一个线程执行IO操作时，它将被阻塞，直到操作完成。
- IO通常使用单线程处理多个连接，每个连接都需要一个独立的线程来处理。
- IO在处理大量连接时性能较低，因为每个连接都需要一个独立的线程，线程切换和上下文切换开销较大。
  **Java NIO（非阻塞IO）：**
- 基于通道（Channel）和缓冲区（Buffer）的概念，使用Channel进行读写操作，数据通过Buffer进行传输。
- NIO操作是非阻塞的，当一个线程执行NIO操作时，它可以继续执行其他任务，而不必等待操作完成。
- NIO使用选择器（Selector）来监听多个通道的事件，一个线程可以处理多个连接。
- NIO适用于处理大量连接的高并发场景，因为它使用单线程来处理多个连接，减少了线程切换和上下文切换的开销。
- NIO提供了更高级的功能，如内存映射文件、非阻塞的Socket通信、文件锁定等。
  **对比：**
- API和编程模型：传统IO使用字节流和字符流进行读写，而NIO使用通道和缓冲区进行读写。NIO的API更加底层，需要手动管理缓冲区和通道，但提供了更高级的功能和灵活性。
- 阻塞与非阻塞：传统IO是阻塞的，而NIO是非阻塞的。传统IO在进行IO操作时会阻塞线程，而NIO可以在等待IO操作完成时继续执行其他任务。
- 处理能力：传统IO需要为每个连接创建一个线程，而NIO使用单线程处理多个连接，提供了更高的并发处理能力。
- 性能：在处理大量连接时，NIO通常比传统IO具有更好的性能，因为它减少了线程切换和上下文切换的开销。
- 功能和扩展性：NIO提供了更多高级功能，如选择器、内存映射文件等，可以更灵活地处理各种I/O操作。
  总的来说，传统IO适用于简单的I/O操作，而NIO适用于需要处理大量连接和高并发的场景，提供了更高级的功能和更好的性能。但是，NIO的编程模型相对复杂一些，需要更多的代码和理解。

## 12.2 关键字对比

### 12.2.1 final 与 finally

> 1. `final` 关键字用于修饰类、方法和变量，表示不可改变或不可继承的特性
>    
>    - 修饰类时，`final` 表示该类是最终的，不能被继承
>    
>    - 修饰方法时，`final` 表示该方法是最终的，不能被子类重写
>    
>    - 修饰变量时，`final` 表示该变量是一个常量，其值不能被修改，常量一旦被赋值后，其值就不能再改变
> 
> 2. `finally` 关键字用于定义代码块，该代码块中的语句无论是否发生异常都会被执行，用于在异常处理完成后执行一些必要的清理操作

### 12.2.2 throw 与 throws

> 1. `throw`关键字用于手动抛出异常对象
> 
> 2. `throws` 关键字用于在方法声明中指定方法可能抛出的异常类型

### 12.2.3 this 与 super

> 1. `this` 关键字表示对当前对象的引用，用于访问当前对象的成员变量、成员方法和构造方法
> 
> 2. `super` 关键字表示对父类对象的引用，用于访问父类的成员变量、成员方法和构造方法

## 12.3  方法 / 语法对比

### 12.3.1 == 和 equals

1. "==" 是比较运算符，对于基本数据类型比较值是否相等，对于对象会检查引用是否指向同一个内存地址
   
   ```java
   String str1 = "Hello";
   String str2 = "Hello";
   String str3 = new String("Hello");
   
   System.out.println(str1 == str2); // true，str1和str2引用同一个字符串常量
   System.out.println(str1 == str3); // false，str1和str3引用不同的对象
   ```

2. "equals" 方法继承自Object类，比较两个对象内容是否相等，默认情况下使用Object类的 "equals" 方法，可以被子类重写以提供自定义的相等比较逻辑
   
   ```java
   System.out.println(str1.equals(str2)); // true
   System.out.println(str1.equals(str3)); // true
   ```

### 12.3.2 do 循环和 while 循环

> **相同** ：用于重复执行一段代码，可以根据条件控制循环的执行次数，直到满足退出条件

> 1. **循环条件的位置** ：do-while循环的循环条件位于循环体末尾，while循环的循环条件位于循环体的开始
> 
> 2. **条件判断时机** ：do-while循环在每次循环结束后判断条件，while循环在每次循环开始前判断条件
> 
> 3. **适用场景** ：do-while循环适用于至少需要执行一次循环体的情况，while循环适用于不确定循环体是否需要执行的情况，循环体可能一次都不执行

### 12.3.3 & 和 &&

**功能对比：**

1. `&`（按位与）：
   - `&`是一个位运算符，用于对两个操作数的每个对应位执行逻辑与操作
   - 对于布尔类型的操作数，`&`会计算两个操作数的逻辑与，并返回一个布尔值结果
   - `&`运算符对于两个操作数，无论是否为true或false，都会进行逻辑与运算
2. `&&`（逻辑与）：
   - `&&`是一个短路逻辑运算符，用于对两个操作数进行逻辑与操作。
   - 对于布尔类型的操作数，`&&`会计算两个操作数的逻辑与，并返回一个布尔值结果。
   - `&&`运算符具有短路特性，即如果第一个操作数为false，那么不会对第二个操作数进行求值，直接返回false。
     **使用方式对比：**
3. `&`：
   - `&`可以用于任何类型的操作数，包括布尔类型和整数类型。
   - 对于整数类型的操作数，`&`会对两个操作数的每个对应位执行按位与操作。
4. `&&`：
   - `&&`只能用于布尔类型的操作数。
   - `&&`具有短路特性，可以用于优化代码，避免不必要的计算。

### 12.3.4 sleep() 和 wait()

1. `sleep()`方法是`Thread`类的静态方法，而`wait()`方法是`Object`类的实例方法
2. `sleep()`方法使当前线程暂停执行一段时间，不会释放持有的锁。它接受一个时间参数，以毫秒为单位，指定暂停的时间长度。一旦暂停时间结束，线程会重新进入可运行状态。`wait()`方法使当前线程进入等待状态，并释放它所持有的锁，以便其他线程可以获取该锁并执行。线程会一直等待，直到被其他线程调用相同对象上的`notify()`或`notifyAll()`方法唤醒
3. `sleep()`方法是为了提供时间间隔的延迟，常用于定时任务或简单的时间等待。`wait()`方法则是用于线程间的通信和协调，常与`notify()`和`notifyAll()`方法一起使用

**相同点：**

- `sleep()`和`wait()`都是Java中用于线程控制的方法。
- 它们都可以暂停线程的执行，使线程进入等待状态。
- 在调用`sleep()`和`wait()`后，线程都会暂停执行，并且会释放持有的锁。
  **不同点：**
- `sleep()`是`Thread`类的静态方法，而`wait()`是`Object`类的实例方法。因此，`sleep()`可以直接通过类名调用，而`wait()`需要通过对象引用调用。
- `sleep()`方法会让线程进入阻塞状态，并且不会主动释放锁，直到指定的时间过去或者被中断。而`wait()`方法会让线程进入等待状态，并且会释放持有的锁，直到被其他线程调用`notify()`或`notifyAll()`方法来唤醒。
- `sleep()`方法可以在任何地方使用，而`wait()`方法必须在同步代码块或同步方法中使用，因为它需要获取对象的监视器锁。
- `sleep()`方法的调用不依赖于对象的状态，而`wait()`方法的调用通常依赖于某种条件的满足。
- `sleep()`方法是线程的静态方法，它可以在任何地方调用。而`wait()`方法是对象的实例方法，只能在持有对象的锁的范围内调用。
  总的来说，`sleep()`和`wait()`都可以暂停线程的执行，但它们的使用方式和效果有所不同。`sleep()`主要用于暂停线程的执行一段时间，而`wait()`主要用于等待其他线程的通知或满足特定条件。

### 12.3.5 start() 和 run()

- `start()` 方法用于启动一个新的线程。当调用 `start()` 方法时，会在后台创建一个新的线程，并开始执行线程的任务。这样可以实现并发执行，使得多个线程可以同时运行。`start()` 方法会立即返回，不会等待线程执行完成。

- `run()` 方法是线程的实际执行代码。当线程被启动后，它会自动调用 `run()` 方法开始执行线程的任务。`run()` 方法中包含了线程需要执行的代码逻辑。需要注意的是，直接调用 `run()` 方法并不会创建一个新的线程，而是在当前线程中执行 `run()` 方法中的代码。因此，使用 `run()` 方法执行任务时，不会实现并发执行，而是按照顺序在当前线程中执行。
  下面是一个对比示例，展示了 `start()` 和 `run()` 方法的不同行为：
  
  ```python
  import threading
  def my_thread_func():
  for i in range(5):
  print("This is thread 1.")
  # 创建线程对象
  my_thread = threading.Thread(target=my_thread_func)
  # 使用 start() 方法启动线程
  my_thread.start()
  # 使用 run() 方法执行线程任务
  my_thread.run()
  for i in range(5):
  print("This is the main thread.")
  ```
  
  在上面的示例中，我们创建了一个线程对象 `my_thread`，并将其目标函数设置为 `my_thread_func`。然后，我们分别使用 `start()` 和 `run()` 方法来启动线程和执行线程任务。同时，主线程也会执行自己的任务。
  当我们运行这段代码时，会发现使用 `start()` 方法启动线程后，线程和主线程会交替执行，实现了并发执行。而使用 `run()` 方法执行线程任务时，线程的执行会在主线程之后，按照顺序执行，没有实现并发执行。
  因此，一般情况下，我们应该使用 `start()` 方法来启动线程，以实现并发执行。而直接调用 `run()` 方法一般用于特殊需求，例如在单线程环境下模拟多线程的行为，或者需要在当前线程中执行线程任务的特殊情况。

### 12.3.6 join() 和 yield()

`join()`和`yield()`是Java中的两个线程控制方法，它们有以下几点不同之处：

1. 功能不同：
   - `join()`方法用于等待线程执行完成。当一个线程调用另一个线程的`join()`方法时，它会被阻塞，直到被调用的线程执行完毕才会继续执行。
   - `yield()`方法用于让出CPU的执行权。当一个线程调用`yield()`方法时，它会暂停当前线程的执行，让其他具有相同优先级的线程有机会执行。
2. 使用方式不同：
   - `join()`方法是通过线程对象调用的，例如`thread.join()`，其中`thread`是要等待执行完成的线程对象。
   - `yield()`方法是通过静态方法`Thread.yield()`调用的，可以直接在代码中使用。
3. 阻塞与暂停：
   - `join()`方法会阻塞当前线程，直到被调用的线程执行完毕。
   - `yield()`方法只是暂停当前线程，让其他线程有机会执行，但不会阻塞当前线程的执行。
4. 用途不同：
   - `join()`方法常用于需要等待其他线程执行完毕后再继续执行的场景，例如主线程等待子线程执行完毕后再进行后续操作。
   - `yield()`方法常用于多个线程之间的协调和调度，让其他线程有机会执行，提高线程的公平性和效率。
     总结起来，`join()`方法用于等待线程执行完成，阻塞当前线程；而`yield()`方法用于让出CPU的执行权，暂停当前线程，让其他线程有机会执行。它们的使用方式、功能和用途都有所不同，根据具体的需求和场景选择适合的方法。

## 12.4 类对比

### 12.4.1 error 和 exception

在Java中，"Error"和"Exception"是两种不同的错误类型。下面是它们之间的对比：
**Error：**

- Error是指程序在运行时遇到的严重问题，通常表示系统级别的错误或资源耗尽。
- Error通常是由Java虚拟机（JVM）或底层系统引起的，例如内存溢出（OutOfMemoryError）、栈溢出（StackOverflowError）等。
- Error通常是无法通过代码处理或捕获的，因为它们表示严重的问题，程序无法继续正常执行。
- 当程序出现Error时，通常会导致程序终止或崩溃。
  **Exception：**
- Exception是指程序在运行时遇到的可预测的问题或异常情况。
- Exception通常是由应用程序或业务逻辑引起的，例如除零异常（ArithmeticException）、空指针异常（NullPointerException）等。
- Exception可以通过代码进行处理或捕获，以避免程序终止或崩溃。
- Exception分为两种类型：可检查异常（checked exception）和不可检查异常（unchecked exception）。
  - 可检查异常是指在编译时强制要求进行处理或捕获的异常，需要使用try-catch块或throws语句进行处理。
  - 不可检查异常是指不需要强制进行处理或捕获的异常，通常是由程序逻辑错误引起的，例如数组越界异常（ArrayIndexOutOfBoundsException）等。
    **处理方式：**
- 对于Error，通常无法通过代码处理或捕获，因此处理方式有限，一般需要修复代码或增加系统资源。
- 对于Exception，可以通过代码进行处理或捕获，以避免程序终止或崩溃。处理方式包括使用try-catch块捕获异常并处理，或使用throws语句将异常抛出给调用者处理。
  总结起来，"Error"和"Exception"是Java中两种不同的错误类型。Error表示系统级别的严重问题，通常由JVM或底层系统引起，无法通过代码处理或捕获；而Exception表示可预测的问题或异常情况，通常由应用程序或业务逻辑引起，可以通过代码进行处理或捕获。异常分为可检查异常和不可检查异常，可检查异常需要在编译时进行处理或捕获，而不可检查异常则不需要。

### 12.4.2 HashMap 和 HashTable

> **相同** ：`HashMap` 和 `HashTable` 都可以存储键值对，其中键是唯一的，而值可以重复，都使用哈希函数将键映射到存储桶中

> 1. 线程安全性：`HashTable` 是线程安全的，而 `HashMap` 不是。`HashTable` 的方法是同步的，可以在多线程环境下使用，而 `HashMap` 的方法不是同步的，如果在多线程环境下使用 `HashMap`，需要额外的同步机制来确保线程安全
> 
> 2. 空键和空值：`HashMap` 允许使用空键和空值，而 `HashTable` 不允许。在 `HashMap` 中，可以使用 `null` 作为键或值，但在 `HashTable` 中，如果尝试存储空键或空值，会抛出 `NullPointerException`
> 
> 3. 迭代顺序：`HashMap` 不保证迭代顺序，而 `HashTable` 以插入顺序迭代元素
> 
> 4. 性能：由于 `HashTable` 的方法是同步的，它的性能通常比 `HashMap` 差。在单线程环境下，`HashMap` 的性能更好，因为它不需要进行额外的同步操作

### 12.4.3 HashMap 和 ConcurrentHashMap

> `HashMap` 和 `ConcurrentHashMap` 都可以存储键值对，其中键是唯一的，而值可以重复。哈希函数：它们都使用哈希函数将键映射到存储桶中

1. 线程安全性：`HashMap` 是非线程安全的，而 `ConcurrentHashMap` 是线程安全的。`ConcurrentHashMap` 的方法是线程安全的，可以在多线程环境下使用，而 `HashMap` 的方法不是线程安全的。在 `ConcurrentHashMap` 中，多个线程可以同时读取和修改不同的部分，而不会产生冲突。这是通过使用分段锁（Segment Locking）或者更高效的 CAS（Compare and Swap）操作来实现的
2. 允许空键和空值：`HashMap` 允许使用空键和空值，而 `ConcurrentHashMap` 不允许。在 `HashMap` 中，可以使用 `null` 作为键或值，但在 `ConcurrentHashMap` 中，如果尝试存储空键或空值，会抛出 `NullPointerException`
3. 迭代顺序：`HashMap` 不保证迭代顺序，而 `ConcurrentHashMap` 也不保证迭代顺序。它们都可以通过 `keySet()`、`values()` 或 `entrySet()` 方法来获取键集合、值集合或键值对集合，并进行迭代
4. 性能：由于 `ConcurrentHashMap` 的方法是线程安全的，它在多线程环境下的性能通常比 `HashMap` 好。在并发读写的情况下，`ConcurrentHashMap` 可以提供更好的吞吐量和更低的延迟。而在单线程环境下，`HashMap` 的性能可能略优于 `ConcurrentHashMap`，因为 `ConcurrentHashMap` 需要额外的同步操作来保证线程安全性

### 12.4.4 Array 和 Arrays

在Java中，`Array`和`Arrays`是两个相关但不同的类。
**Array:**

- `Array`是Java中用于表示数组的关键字。
- 数组是一种固定大小的、具有相同数据类型的连续存储结构。
- 数组可以存储基本数据类型和对象类型。
- 数组的长度在创建时确定，并且不能改变。
- 数组可以通过索引访问和修改元素，索引从0开始。
  **Arrays:**
- `Arrays`是一个包含了一些静态方法的工具类，用于操作和处理数组。
- `Arrays`类中的方法都是静态方法，可以直接通过类名调用。
- `Arrays`类提供了一些常用的操作，例如对数组进行排序、查找元素、复制数组等。
- `Arrays`类还提供了一些用于数组和集合之间的转换的方法。
  **对比：**
- `Array`是Java中用于表示数组的关键字，用于定义和声明数组。
- `Arrays`是一个工具类，提供了对数组进行操作和处理的静态方法。
- `Array`用于表示数组本身，而`Arrays`用于对数组进行操作和处理。
- `Array`表示具体的数组对象，而`Arrays`是一个包含了静态方法的工具类。
  总结起来，`Array`是Java中用于表示数组的关键字，用于定义和声明数组；`Arrays`是一个工具类，提供了对数组进行操作和处理的静态方法。`Array`用于表示数组本身，而`Arrays`用于对数组进行操作。

### 12.4.5 Collection 和 Collections

在Java中，`Collection`和`Collections`是两个相关但不同的类。
**Collection:**

- `Collection`是Java集合框架的根接口，表示一组对象的集合。
- `Collection`接口继承自`Iterable`接口，提供了对集合中元素进行基本操作的方法，例如添加、删除、遍历等。
- `Collection`接口有多个实现类，包括`List`、`Set`和`Queue`等。
- `Collection`接口的实现类可以根据具体需求选择，例如使用`ArrayList`实现动态数组，使用`HashSet`实现无序集合等。
  **Collections:**
- `Collections`是一个包含了一些静态方法的工具类，提供了对集合进行操作的方法。
- `Collections`类中的方法都是静态方法，可以直接通过类名调用。
- `Collections`类提供了一些常用的操作，例如对集合进行排序、查找最大/最小元素、反转集合等。
- `Collections`类还提供了一些用于创建不可修改集合、同步集合等的方法。
  **对比：**
- `Collection`是一个接口，表示一组对象的集合，提供了基本的集合操作方法。
- `Collections`是一个工具类，提供了对集合进行操作的静态方法。
- `Collection`用于表示集合本身，而`Collections`用于对集合进行操作和处理。
- `Collection`接口有多个实现类，而`Collections`是一个包含了静态方法的工具类。
  总结起来，`Collection`是表示一组对象的集合的接口，提供了基本的集合操作方法；`Collections`是一个工具类，提供了对集合进行操作和处理的静态方法。`Collection`用于表示集合本身，而`Collections`用于对集合进行操作。

### 12.4.6 ArrayList 和 LinkedList

在Java中，`ArrayList`和`LinkedList`是两种常见的集合类实现，用于存储和操作数据。它们在底层实现和性能方面有一些区别。下面是它们之间的对比：
**ArrayList:**

- `ArrayList`是基于数组实现的动态数组，可以自动调整大小。
- 内部使用数组来存储元素，通过索引快速访问元素。
- 在尾部添加或删除元素的操作效率较高，时间复杂度为O(1)。
- 在中间或开头插入或删除元素时，需要移动其他元素，时间复杂度为O(n)。
- 适用于频繁访问和遍历元素的场景，但不适合频繁插入和删除元素的场景。
  **LinkedList:**
- `LinkedList`是基于链表实现的双向链表，每个节点都包含对前一个和后一个节点的引用。
- 内部使用链表来存储元素，每个节点包含元素值和指向前后节点的引用。
- 在尾部添加或删除元素的操作效率较高，时间复杂度为O(1)。
- 在中间或开头插入或删除元素时，只需要修改节点的引用，时间复杂度为O(1)。
- 适用于频繁插入和删除元素的场景，但访问和遍历元素的效率相对较低，需要遍历链表。

### 12.4.7 StringBuffer 和 StringBuilder

在Java中，`StringBuffer`和`StringBuilder`都是用于处理可变字符串的类。它们具有相似的功能，但在线程安全性和性能方面有一些区别。下面是它们之间的对比：
**StringBuffer:**

- `StringBuffer`是线程安全的可变字符串类，适用于多线程环境。
- 内部使用字符数组来存储字符串内容，并提供了多个同步方法，以确保线程安全。
- 在进行字符串拼接、插入或删除等操作时，会进行同步处理，保证线程安全。
- 由于同步操作的开销，`StringBuffer`的性能相对较低。
- `StringBuffer`的方法都是线程安全的，可以在多线程环境下使用。
  **StringBuilder:**
- `StringBuilder`是非线程安全的可变字符串类，适用于单线程环境。
- 内部使用字符数组来存储字符串内容，但没有提供同步方法，不进行线程安全处理。
- 在进行字符串拼接、插入或删除等操作时，不进行同步处理，因此性能较高。
- `StringBuilder`的方法都不是线程安全的，不适合在多线程环境下使用。
  **选择使用的考虑因素：**
- 线程安全性：如果在多线程环境中需要进行字符串操作，应选择`StringBuffer`以确保线程安全。
- 性能：如果在单线程环境中进行字符串操作，且对性能有较高要求，应选择`StringBuilder`以获得更好的性能。
- 字符串操作：`StringBuffer`和`StringBuilder`提供了类似的方法，可以进行字符串拼接、插入、删除等操作。因此，具体的字符串操作需求也是选择的考虑因素之一。
  总结起来，`StringBuffer`适用于多线程环境，提供了线程安全的字符串操作方法；而`StringBuilder`适用于单线程环境，提供了更高性能的字符串操作方法。根据线程安全性和性能需求，选择适合的类进行字符串操作。

### 12.4.8 Comparator 和 Comparable

在Java中，`Comparator`和`Comparable`是用于比较对象的接口，它们在实现方式和使用场景上有一些区别。
**Comparable:**

- `Comparable`是一个接口，用于定义对象自身的比较方式。
- 实现了`Comparable`接口的类可以通过实现`compareTo`方法来定义对象之间的比较规则。
- `compareTo`方法返回一个整数值，表示当前对象与另一个对象的比较结果。如果返回负数，表示当前对象小于另一个对象；如果返回正数，表示当前对象大于另一个对象；如果返回0，表示两个对象相等。
- `Comparable`接口的主要使用场景是在集合类中进行排序操作，例如使用`Collections.sort`方法对实现了`Comparable`接口的对象进行排序。
  **Comparator:**
- `Comparator`是一个接口，用于定义独立于对象自身的比较规则。
- `Comparator`接口定义了`compare`方法，可以通过该方法来比较两个对象。
- `compare`方法返回一个整数值，表示两个对象的比较结果。与`Comparable`接口的`compareTo`方法类似，负数表示第一个对象小于第二个对象，正数表示第一个对象大于第二个对象，0表示两个对象相等。
- `Comparator`接口的主要使用场景是在需要灵活定义比较规则的情况下，例如对集合中的对象进行自定义排序。
  **选择使用的考虑因素：**
- 对象的自然排序：如果对象有一个自然的排序方式，可以实现`Comparable`接口，并在`compareTo`方法中定义比较规则。这样可以方便地在集合类中进行排序操作。
- 独立于对象的比较规则：如果需要在不修改对象类的情况下定义比较规则，或者需要多个不同的比较规则，可以实现`Comparator`接口，并在`compare`方法中定义比较规则。这样可以在需要的地方使用不同的比较规则进行排序或比较操作。

### 12.4.9 CyclicBarrier和 CountDownLatch

## 12.5 代码题

### 12.5.1 单例模式

1. 懒汉式-线程不安全 ：这种方式在第一次调用`getInstance()`方法时才创建实例，但在多线程环境下可能会出现线程安全问题
   
   ```java
   public class Singleton {  
       private static Singleton instance;  
   
       private Singleton() {  
           // 私有构造方法，防止外部实例化  
       }  
   
       public static Singleton getInstance() {  
           if (instance == null) {  
               instance = new Singleton();  
           }  
           return instance;  
       }  
   }  
   ```

2. 懒汉式-线程安全 ：通过在`getInstance()`方法上添加`synchronized`关键字，可以解决线程安全问题。但这种方式在多线程环境下性能较差，因为每次调用`getInstance()`都需要进行同步。
   
   ```java
   public class Singleton {  
       private static Singleton instance;  
   
       private Singleton() {  
           // 私有构造方法，防止外部实例化  
       }  
   
       public static synchronized Singleton getInstance() {  
           if (instance == null) {  
               instance = new Singleton();  
           }  
           return instance;  
       }  
   }  
   ```

3. 饿汉式：在类加载时就创建了实例，因此不存在线程安全问题。但如果实例不被使用，会造成资源浪费
   
   ```java
   public class Singleton {  
       private static Singleton instance = new Singleton();  
   
       private Singleton() {  
           // 私有构造方法，防止外部实例化  
       }  
   
       public static Singleton getInstance() {  
           return instance;  
       }  
   }  
   ```

4. 双重检查锁定（Double-Checked Locking）：通过使用双重检查锁定和`volatile`关键字，可以在多线程环境下实现懒加载且线程安全
   
   ```java
   public class Singleton {  
       private volatile static Singleton instance;  
   
       private Singleton() {  
           // 私有构造方法，防止外部实例化  
       }  
   
       public static Singleton getInstance() {  
           if (instance == null) {  
               synchronized (Singleton.class) {  
                   if (instance == null) {  
                       instance = new Singleton();  
                   }  
               }  
           }  
           return instance;  
       }  
   }  
   ```

### 12.5.2 多线程打印奇偶数

在上述代码中，我们创建了一个`PrintOddEven`类，其中包含了`count`（当前数字）、`max`（最大数字）和`lock`（同步锁）等成员变量。`printOdd()`方法用于打印奇数，`printEven()`方法用于打印偶数。在`printOdd()`和`printEven()`方法中，我们使用`synchronized`关键字来保证线程安全。通过使用`wait()`和`notify()`方法来实现线程的交替执行。当满足条件时，打印当前数字并递增`count`，然后通过`notify()`方法唤醒等待的线程，否则当前线程调用`wait()`方法进行等待。在`main()`方法中，我们创建了两个线程，一个用于打印奇数，一个用于打印偶数。然后启动这两个线程，它们将交替打印奇偶数，直到达到最大数字为止。

```java
public class PrintOddEven {
    private int count;
    private int max;
    private Object lock;

    public PrintOddEven(int max) {
        this.count = 1;
        this.max = max;
        this.lock = new Object();
    }

    public void printOdd() {
        synchronized (lock) {
            while (count <= max) {
                if (count % 2 != 0) {
                    System.out.println("Odd: " + count);
                    count++;
                    lock.notify();
                } else {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public void printEven() {
        synchronized (lock) {
            while (count <= max) {
                if (count % 2 == 0) {
                    System.out.println("Even: " + count);
                    count++;
                    lock.notify();
                } else {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        int maxNumber = 10;
        PrintOddEven printer = new PrintOddEven(maxNumber);

        Thread oddThread = new Thread(() -> printer.printOdd());
        Thread evenThread = new Thread(() -> printer.printEven());

        oddThread.start();
        evenThread.start();
    }
}
```

## 12.6 其他问题

### 12.6.1 开发常用包

> 1. **java.lang**：提供Java的核心类和基本功能，如`Object`、`String`、`Math`
> 
> 2. **java.util**：提供了各种实用的数据结构和算法，如集合框架（`List`、`Set`、`Map`等）、日期和时间处理、随机数生成、输入输出
> 
> 3. java.io：提供了输入输出相关的类和接口，用于读取和写入数据到文件、流
> 
> 4. java.nio：提供了新的I/O（Input/Output）API，用于高效的非阻塞I/O操作
> 
> 5. java.util.concurrent：提供了并发编程相关的类和接口，用于多线程编程、线程池管理、并发集合
> 
> 6. java.sql：提供了Java数据库连接（JDBC）的相关类和接口，用于连接和操作数据库
> 
> 7. java.net：提供了网络编程相关的类和接口，用于创建网络连接、进行网络通信等
> 
> 8. java.awt：提供了抽象窗口工具包（Abstract Window Toolkit），用于创建图形用户界面（GUI）应用程序
> 
> 9. javax.swing：提供了Swing工具包，用于创建跨平台的GUI应用程序，包括各种组件、布局管理器
> 
> 10. java.security：提供了安全相关的类和接口，用于数据加密、数字签名、访问控制等安全功能

### 12.6.2 String 如何实现不可变

1. **String类的底层实现：** `String`类内部使用字符数组（`char[]`）来存储字符串的值。这个字符数组被声明为`final`，所以它的引用不能被改变。这样一来，一旦创建了一个`String`对象，就不能再修改它的值
2. **String的方法返回新的String对象：** `String`类中的大多数方法（例如`substring()`、`concat()`等）都返回一个新的`String`对象，而不是修改原始对象。这样做可以确保原始的`String`对象保持不变
3. **字符串连接的优化：** 在使用`+`操作符连接字符串时，Java编译器会自动优化为使用`StringBuilder`来构建新的字符串。`StringBuilder`是可变的，但在连接完成后会生成一个不可变的`String`对象

### 12.6.3 String 不可变的目的

- **安全性** 不可变的字符串可以用作密码、敏感信息等，因为它们的值无法被修改，从而提供了更高的安全性。字符串的不可变性可以保证其内容不会被意外修改。在多线程环境下，如果字符串是可变的，可能会导致数据竞争和不一致的状态。通过使字符串不可变，可以避免这些问题。不可变的字符串在多线程环境中是线程安全的，因为它们的值不能被修改。这样就避免了多线程并发修改字符串对象的问题
- **缓存哈希值：** 不可变的字符串可以被安全地用作哈希表的键，因为它们的哈希值是不变的。这样可以提高哈希表的性能。字符串的不可变性使得字符串的哈希值在创建时就可以被缓存下来，提高了字符串在哈希表等数据结构中的查找效率。如果字符串是可变的，那么每次修改字符串的值都需要重新计算哈希值，影响性能
- **优化：** 不可变的字符串可以进行一些优化，例如字符串连接的优化，避免频繁的字符串复制操作。Java中的字符串常量池是一块特殊的内存区域，用于存储字符串常量。由于字符串的不可变性，可以在字符串常量池中共享字符串对象，减少内存占用和提高性能。字符串的不可变性使得字符串对象可以被安全地共享和重用。例如，多个字符串变量可以指向同一个字符串对象，而无需创建多个副本。这种共享和重用可以提高内存利用率和执行效率

### 12.6.4 ConcurrentHashMap 如何实现线程安全

1. **分段锁（Segment）：** `ConcurrentHashMap`内部被分成多个段（Segment），每个段维护着一个独立的哈希表。不同的线程可以同时访问不同的段，从而实现了并发的读写操作。每个段都有自己的锁，当一个线程访问某个段时，只需要锁住该段，而不是整个哈希表
2. **读写分离：** `ConcurrentHashMap`允许多个线程同时进行读操作，而不需要互斥锁。这是通过使用volatile修饰的读写标记来实现的。读操作不会阻塞其他读操作，从而提高了并发读取的性能
3. **线程安全的原子操作：** `ConcurrentHashMap`提供了一些线程安全的原子操作，例如`putIfAbsent()`、`remove()`等。这些操作能够在不需要额外的同步措施的情况下进行原子性的更新
4. **不会引发`ConcurrentModificationException`：** `ConcurrentHashMap`的迭代器使用了一种弱一致性的迭代方式，不会抛出`ConcurrentModificationException`异常。迭代器在遍历时会遍历到某个时刻为止的快照，而不是实时的数据

### 12.6.5 线程池常用参数

1. 核心线程数（Core Pool Size）：线程池中始终保持的线程数。即使线程处于空闲状态，也不会被销毁，除非线程池被关闭。这个参数可以通过调用线程池的`setCorePoolSize(int corePoolSize)`方法来设置
2. 最大线程数（Maximum Pool Size）：线程池中允许的最大线程数。当任务数量超过核心线程数时，线程池会创建新的线程来处理任务，但是不会超过最大线程数。这个参数可以通过调用线程池的`setMaximumPoolSize(int maximumPoolSize)`方法来设置
3. 空闲线程存活时间（Keep Alive Time）：当线程池中的线程数量超过核心线程数，并且空闲时间超过指定的时间时，多余的线程会被销毁，以减少资源消耗。这个时间可以通过调用线程池的`setKeepAliveTime(long time, TimeUnit unit)`方法来设置
4. 阻塞队列（Blocking Queue）：用于存储等待执行的任务的队列。当线程池中的线程都在执行任务时，新的任务会被放入队列中等待执行。Java提供了多种类型的阻塞队列，例如`ArrayBlockingQueue`、`LinkedBlockingQueue`等。可以通过调用线程池的`setQueue(BlockingQueue<Runnable> queue)`方法来设置队列类型和大小
5. 拒绝策略（Rejected Execution Handler）：当线程池无法执行新的任务时，会采取的策略。常见的策略包括抛出异常、丢弃任务、丢弃队列中最旧的任务等。可以通过调用线程池的`setRejectedExecutionHandler(RejectedExecutionHandler handler)`方法来设置拒绝策略

### 12.6.6 ArrayList扩容机制

1. 初始容量：当创建一个ArrayList对象时，会分配一个初始容量。<mark>默认初始容量为10</mark>
2. 添加元素：当向ArrayList中添加元素时，如果当前元素数量已经达到了容量上限，则需要进行扩容操作
3. 扩容策略：ArrayList会创建一个新的数组，并将原来的元素复制到新的数组中。新数组的容量通常是原数组的1.5倍（在JDK 1.6之前是原数组容量的2倍），这是为了平衡空间利用率和扩容频率
4. 扩容操作：扩容操作会涉及到数组的拷贝，因此会有一定的性能开销。当数组需要扩容时，ArrayList会创建一个新的更大容量的数组，并将原数组中的元素复制到新数组中。这个过程可以通过调用`Arrays.copyOf()`方法来完成
5. 更新容量：扩容后，ArrayList的容量会更新为新数组的容量

### 12.6.7 HashMap扩容机制

1. 初始容量：当创建一个HashMap对象时，会分配一个初始容量，<mark>默认初始容量为16</mark>
2. 负载因子：HashMap还有一个负载因子的概念，表示哈希表在达到多满时进行扩容。默认情况下，负载因子为0.75。这意味着当HashMap中的元素数量达到容量的75%时，就会触发扩容操作。
3. 扩容操作：当HashMap需要进行扩容时，会创建一个新的更大容量的哈希表，并将原哈希表中的元素重新分配到新哈希表中。扩容操作会导致所有的原有元素重新计算哈希值，并放置到新的位置上。
4. 容量调整：扩容操作会将容量翻倍，即新哈希表的容量是原哈希表容量的两倍。这是为了保持哈希表的效率，减少哈希冲突的概率。
5. 重新哈希：在扩容操作中，HashMap会重新计算每个元素的哈希值，并根据新的容量重新放置到新哈希表的对应位置上。这个过程会涉及到元素的重新散列，因此会有一定的性能开销。

### 12.6.7 创建对象的方式

1. 使用关键字`new`：最常见的创建对象的方式是使用`new`关键字，后跟要实例化的类的构造函数
   
   ```java
   MyClass obj = new MyClass();
   ```

2. 使用反射机制：Java的反射机制提供了一种在运行时动态创建对象的方式。可以使用`Class`类的`newInstance()`方法来创建对象。从Java 9开始，`newInstance()`方法已被弃用，建议使用`getDeclaredConstructor().newInstance()`方法
   
   ```java
   Class<?> clazz = MyClass.class;
   MyClass obj = (MyClass) clazz.newInstance();
   ```

3. 使用`clone()`方法：如果一个类实现了`Cloneable`接口，就可以使用`clone()`方法来创建该类的对象的副本。为了正确地使用`clone()`方法，需要确保被克隆的类正确地实现了`Cloneable`接口，并且重写了`clone()`方法
   
   ```java
   MyClass obj1 = new MyClass();
   MyClass obj2 = obj1.clone();
   ```

4. 使用反序列化：通过反序列化也可以创建对象。可以将一个对象序列化到磁盘或通过网络传输，然后再将其反序列化为一个新的对象。为了进行对象的反序列化，需要确保对象所属的类实现了`Serializable`接口
   
   ```java
   // 序列化对象
   MyClass obj1 = new MyClass();
   ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("obj.ser"));
   out.writeObject(obj1);
   out.close();
   // 反序列化对象
   ObjectInputStream in = new ObjectInputStream(new FileInputStream("obj.ser"));
   MyClass obj2 = (MyClass) in.readObject();
   in.close();
   ```

### 12.6.8 泛型通配符以及上下界

泛型通配符是一种特殊的类型参数，用于表示不确定的类型。在Java中，有三种类型的泛型通配符：`?`、`? extends`和`? super`。

1. **无界通配符 (`?`)**: 使用`?`表示。它表示可以匹配任意类型的泛型参数。在使用无界通配符时，我们无法对泛型参数进行具体的操作，只能进行与类型无关的操作。
   例如，可以使用无界通配符来表示一个未知类型的List：
   
   ```java
   List<?> list = new ArrayList<>();
   ```

2. **上界通配符 (`? extends 类型`)**: 使用`? extends 类型`表示。它表示泛型参数是某个类的子类，或者实现了某个接口。上界通配符允许读取数据，但不能写入。
   例如，可以使用上界通配符来表示一个只能读取`Number`及其子类的List：
   
   ```java
   List<? extends Number> list = new ArrayList<>();
   ```

3. **下界通配符 (`? super 类型`)**: 使用`? super 类型`表示。它表示泛型参数是某个类的父类。下界通配符允许写入数据，但读取时只能作为`Object`类型处理。
   例如，可以使用下界通配符来表示一个只能写入`Number`及其父类的List：
   
   ```java
   List<? super Number> list = new ArrayList<>();
   ```
   
   使用泛型通配符可以增加代码的灵活性和复用性，使得泛型类型可以适应更广泛的场景。但需要注意的是，在使用通配符时，对泛型参数的操作是受限的，因为编译器无法确定具体的类型。因此，在使用通配符时，通常只能进行与类型无关的操作，如读取数据或调用不依赖具体类型的方法。

### 12.6.9 Integer 使用 == 判断相等或者不相等的情况

1. 在范围内的整数：对于整型数值在-128到127之间的 `Integer` 对象，使用 `==` 运算符进行比较时，会显示相等，因为它们引用的是同一个对象。这是由于对象池（object pool）机制的缓存策略导致的。
   
   ```java
   Integer num1 = 100;
   Integer num2 = 100;
   
   if (num1 == num2) {
       System.out.println("num1 and num2 are equal");
   } else {
       System.out.println("num1 and num2 are not equal");
   }
   ```
   
   输出结果为 "num1 and num2 are equal"。

2. 超出范围的整数或使用 `new` 关键字创建的对象：对于超出范围的整型数值或使用 `new` 关键字创建的 `Integer` 对象，它们不会被缓存到对象池中。因此，使用 `==` 运算符比较时，会比较它们的引用地址，而不是比较它们的值。
   
   ```java
   Integer num1 = 200;
   Integer num2 = new Integer(200);
   
   if (num1 == num2) {
       System.out.println("num1 and num2 are equal");
   } else {
       System.out.println("num1 and num2 are not equal");
   }
   ```
   
   输出结果为 "num1 and num2 are not equal"。

总结：对于整型数值在-128到127之间的 `Integer` 对象，使用 `==` 运算符进行相等判断可能会显示相等，因为它们引用的是同一个对象。对于超出范围的整型数值或使用 `new` 关键字创建的 `Integer` 对象，应该使用 `equals()` 方法来比较它们的值是否相等。

### 12.6.10 synchronized 与 ReentrantLock
