# 1 软件测试

> 测试是以评价一个程序或系统属性为目标的任何一种活动，测试是对软件质量的度量。使用人工或自动的手段来运行或测定某个软件系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别

## 1.1 软件测试分类

### 1.1.1 测试阶段

1. 单元测试：针对程序中的最小可测试单元进行测试，通常由开发人员执行
2. 集成测试：测试不同单元模块之间的交互，以确保它们在一起工作正常
3. 系统测试：对整个系统进行测试，验证其是否符合需求规格说明书中的要求
4. 验收测试：由最终用户或客户执行，以确认系统是否符合其预期的需求和规格

### 1.1.2 测试实施组织

1. 开发方测试：开发方测试是由软件开发团队内部进行的测试活动

2. 用户测试：由最终用户或代表用户利益的人员进行的测试活动

3. 第三方测试：由独立于软件开发团队和最终用户的外部实体进行的测试活动

### 1.1.3 测试对象

1. 功能测试：验证系统的功能是否按照规格说明书中的要求正常工作
2. 性能测试：评估系统的性能，如响应时间、吞吐量和稳定性
3. 安全性测试：评估系统对于未经授权的访问、数据保护和其他安全方面的表现
4. 可靠性测试：对系统在特定条件下的稳定性和可靠性进行评估，旨在确保系统在长时间运行、高负载或异常情况下仍能保持稳定性
5. 兼容性测试：确保系统在不同的操作系统、浏览器、设备上都能正常运行
6. 可移植性测试：

### 1.1.4 测试方法

1. 手动测试：测试人员通过手动操作系统来验证其功能和性能
2. 自动化测试：使用脚本和工具来自动执行测试用例，以提高效率和覆盖范围

### 1.1.5 测试

1. 静态测试：在不执行代码的情况下对软件进行检查和分析的过程，包括代码审查、需求分析、系统设计和测试计划等
2. 动态测试：在执行代码的情况下对软件进行测试和验证的过程，包括单元测试、集成测试、系统测试和验收测试等

### 1.1.6 测试策略

1. 黑盒测试：测试人员只关注系统的输入和输出，而不考虑内部结构和实现细节
2. 灰盒测试：这种测试方法介于黑盒测试和白盒测试之间，测试人员对系统的一部分内部结构和实现细节有一定了解，并根据这些了解来设计测试用例
3. 白盒测试：测试人员了解系统的内部结构和实现细节，并据此设计测试用例

## 1.2 软件测试原则

1. **尽早测试**：早期测试可以帮助在软件开发周期的早期阶段发现并解决问题，减少后期修复的成本和风险

2. **可追溯性**：测试用例和缺陷是可追溯的，可以跟踪到测试用例是如何与需求相关联的，以及缺陷是如何与测试用例相关联的

3. **回归测试**：回归测试确保新的更改没有破坏现有的功能

4. **80 / 20原则**：大约80%的问题通常来自于20%的原因，应该重点关注最有可能引起问题的功能或模块

5. **投入 / 产出原则**：权衡投入和产出，即确保投入的测试工作能够产生相应的价值和成果，避免过度投入但产出不相称

## 1.3 软件测试模型

### 1.3.1 瀑布模型

> 瀑布模型将项目开发过程划分为一系列线性阶段，每个阶段的输出成为下一个阶段的输入，测试在开发完成后才进行

- **计划** 阶段涉及确定项目的目标、范围、资源需求和时间表

- **需求分析** 阶段包括收集、确认和记录用户对系统的需求和期望

- **设计** 阶段涉及将需求转化为系统架构和规范

- **编码** 阶段是根据设计规范实际编写和构建软件系统的阶段

- **测试** 阶段包括验证软件是否符合规格说明书中的要求，包括功能、性能和可靠性等方面

- **运行维护** 阶段是指软件部署后的阶段，涉及确保软件在生产环境中持续稳定运行并对其进行必要的维护和支持

<img title="" src="https://th.bing.com/th/id/R.09a0dea7efb98779776245b6eaaaf223?rik=J5WQJw10M0vvzA&riu=http%3a%2f%2fpic.cnitpm.com%2fupload%2fimg%2f2012-06-19%2fe1a19ee1-bf93-4d04-b7e2-b8e6b822e44b.jpg&ehk=aW4pcDEitRu9DrRCay7rDEXA%2frBd06WTD5DxWMlFe7w%3d&risl=&pid=ImgRaw&r=0" alt="" data-align="center" width="544">

### 1.3.2 V模型

<img title="" src="https://p1.ssl.qhmsg.com/t01a5c0d5c9f35b0155.jpg" alt="" data-align="center">

### 1.3.3 W模型

![](https://melovemingming-1253878077.cos.ap-chengdu.myqcloud.com/blog-image/2018/10/09/10.png)

### 1.3.4 H模型

> H模型中, 软件测试过程活动完全独立,贯穿于整个产品的周期,与其他流程并发地进行`,某个测试点准备就绪时,就可以从测试准备阶段进行到测试执行阶段。软件测试可以尽早进行,并且可以根据被测物的不同而分层次进行

### 1.3.5 X模型

> 很好地处理测试与开发的交接过程（交接的过程是一个时间段，而不是一个点）
> 
> 左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成最终合成为可执行的程序，然后再对这些可执行程序进行测试。
> 
> 己通过集成测试的成品可以进行封装并提交给用户，也可以作为更大规模和范围内集成的一部分。多根并行的曲线表示变更可以在各个部分发生。
> 
> X模型还定位了探索性测试，这是不进行事先计划的特殊类型的测试，给有经验的测试人员在测试计划之外发现更多的软件缺陷

## 1.4 软件测试文档

## 1.5 测试用例（Test Case）

> 测试用例是一组条件、输入、执行步骤和预期结果的集合，用于验证软件系统是否按照预期进行工作

### 1.5.1 测试用例组成

1. **用例ID**：用于唯一标识测试用例的编号

2. **用例名称**：用于唯一标识测试用例的名称

3. **测试目标**：清晰地说明该测试用例的目的，即要测试的具体功能或情景

4. **测试级别**：

5. **前提条件**：描述执行该测试用例所需的输入条件，包括数据、环境或其他先决条件

6. **测试步骤**：详细描述执行测试用例的步骤，包括操作界面、输入数据等

7. **测试数据**：

8. **预期结果**：执行测试用例后所期望得到的结果

9. **实际结果**：执行测试用例后实际观察到的结果，用于与预期结果进行比较

10. **测试状态**：标识该测试用例的执行状态，例如“通过”、“失败”或“阻塞”

### 1.5.2 测试用例设计原则

1. **代表性**：测试用例应该代表系统功能的各个方面，覆盖不同的情况和场景，以确保对系统功能的全面测试

2. **非重复性**：测试用例之间应该互相独立，避免重复测试相同的功能或情景，以提高测试效率并避免冗余的测试

3. **<mark>可判定性</mark>**：测试用例的结果应该是可以判定的，即根据测试用例执行的结果能够明确判断系统功能是否符合预期

4. **可再现性**：测试用例设计应该能够产生可再现的结果，即相同的测试条件下反复执行测试用例能够得到相同的结果，这有助于确认和修复缺陷

<!--GFM-TOC -->

<!--GFM-TOC -->

## 1.6 软件缺陷

> 软件缺陷是指在软件开发过程中引入的错误、问题或不符合规范的部分，可能导致系统功能异常或不符合预期

### 1.6.1 缺陷分类

1. **功能性缺陷**：软件功能的错误或不完整

2. **性能缺陷**：包括响应时间过长、系统负载过大时的异常行为、资源占用过高等问题，可能导致系统性能不佳

3. **安全性缺陷**：涉及系统对数据的保护不足、易受攻击、存在漏洞等问题，可能导致系统容易受到恶意攻击或者数据泄露

4. **兼容性缺陷**：指软件在不同环境、平台或设备上的不一致性，可能导致软件在某些环境下无法正常工作

5. **可靠性缺陷**：软件在长时间运行或特定条件下出现的不稳定性、崩溃或数据丢失等问题

6. **易用性缺陷**：软件界面设计不合理、用户交互体验不佳、操作不直观等问题，可能导致用户体验差

7. **维护性缺陷**：软件代码质量低、结构不清晰、难以维护和扩展的问题，可能导致后续开发和维护成本增加

### 1.6.2 缺陷流程

![](https://imgconvert.csdnimg.cn/aHR0cDovL2Jicy5pdGhlaW1hLmNvbS9kYXRhL2F0dGFjaG1lbnQvZm9ydW0vMjAxOTA4LzI3LzE1MDE1MHJvb2V4eXl2ZTd6cWhlOW0ucG5nLnRodW1iLmpwZw?x-oss-process=image/format,png)

## 1.7 软件质量模型

> 软件质量模型是用来描述和评估软件质量的框架或标准，通常包括一系列的特征、属性或度量，以帮助衡量软件产品的质量

1. **功能性**：软件功能是否满足了用户的需求和期望，包括准确性、互操作性、安全性等

2. **可靠性**：软件在规定条件下保持其性能的能力，包括可用性、容错性、成熟性等

3. **易用性**：软件是否易于修改、测试、调试，包括可分析性、可改变性、稳定性等

4. **效率**：软件在规定条件下的性能与资源利用的关系，包括时间、资源利用、容量等

5. **可用性**：软件对用户可接受程度的影响，包括易理解性、操作性、吸引力等方面

6. **可移植性**：软件在不同环境下的适应性，包括适应性、安装性、互换性等方面

<img src="https://img-blog.csdnimg.cn/20190211103514660.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE3NjExMg==,size_16,color_FFFFFF,t_70" title="" alt="" data-align="center">

# 2 黑盒测试

> 黑盒测试关注于测试软件的功能，而不考虑内部实现细节，测试人员不考虑程序或软件的内部结构或逻辑，只关心输入和输出，以验证软件是否按照规格说明书的要求正常工作

## 2.1 黑盒测试优缺点

### 2.1.1 优势

1. 黑盒测试与软件具体实现无关，即使软件实现发生了变化，测试用例仍然可以使用

2. 设计黑盒测试用例可以和软件实现同时进行

### 2.1.2 劣势

1. 黑盒测试难以查找出错误的具体原因和位置

2. 黑盒测试依赖于软件的需求规格说明书，无法发现需求规格说明本身存在的问题

## 2.2 常用黑盒测试用例设计方法

### 2.2.1 等价类划分

> 等价类划分将输入数据划分为相互等价的类别，以便在每个类别中选择少量的测试用例进行测试，如有效等价与无效等价

### 2.2.2 边界值分析

> 边界值分析关注测试输入数据的边界情况，即
> 
> 1. **上点**：上点是指处于边界上的值，即最大值和最小值。在边界值分析中，上点是指刚好位于边界上的值，通常包括最大值和最小值
> 2. **内点**：内点是指位于边界内部的值，即介于最大值和最小值之间的值。在边界值分析中，内点是指介于最大值和最小值之间的值，用于测试系统在这些内部值情况下的行为
> 3. **离点**：离点是指远离边界的值，即远离最大值和最小值的值。在边界值分析中，离点是指远离最大值和最小值的值，通常用于测试系统在极端情况下的行为

### 2.2.3 判定表（Decision Table）

> 判定表用于描述系统的决策逻辑和生成测试用例，用于系统具有多个条件和行为的情况下，有助于组织和管理这些条件与行为之间的关系
> 
> 1. **条件桩**：条件桩描述条件项的具体取值范围或条件成立的情况
> 
> 2. **动作桩**：动作桩描述了动作项对应的具体操作或输出
> 
> 3. **条件项**：系统的各种输入、状态或事件，构成了系统决策的基础
> 
> 4. **动作项**：系统对于条件变化所做出的响应或动作

### 2.2.4 因果图法（Cause-Effect Graphing）

> 因果图法用于识别和建模系统中的输入和输出之间的因果关系，帮助测试人员在输入之间存在复杂相互影响的情况下设计测试用例，以覆盖各种因果关系

### 2.2.5 错误推测法（Error Guessing）

> 错误推测法是一种基于测试人员的经验和直觉来推测可能存在的错误，并设计测试用例以验证这些错误的测试方法。这种方法并不依赖于正式的测试文档或规范，而是依赖于测试人员的直觉和经验来发现潜在的问题

### 2.2.6 正交试验法

### 2.2.7 场景法

### 2.2.8 功能图法

# 3 白盒测试（White Box Testing）

> 白盒测试也称结构化测试、逻辑驱动测试或基于代码的测试，关注内部结构、设计和实现细节，以验证代码的逻辑正确性

## 3.1 白盒测试优缺点

### 3.1.1 优点

> 1. 可以发现代码逻辑错误和潜在的缺陷
> 
> 2. 可以提供更全面的代码覆盖度
> 
> 3. 有助于改进代码质量和结构

### 3.1.2 缺点

> 1. 对代码的深入了解和技术要求较高
> 
> 2. 难以确保测试覆盖所有可能的情况
> 
> 3. 容易受到代码重构的影响

## 3.1 常用白盒测试用例设计方法

### 控制流测试

### 数据流测试

### 测试覆盖率

常用的白盒测试用例设计方法包括：

1. **控制流图覆盖（Control Flow Graph Coverage）**：基于程序的控制流图来设计测试用例，以确保覆盖所有可能的控制流路径。
   这些方法可以单独或结合使用，以确保对软件系统的各个方面进行全面的测试。选择使用哪种方法通常取决于系统的复杂性、时间限制和测试覆盖的需求。

### 语句覆盖（Statement Coverage）

确保每个代码语句至少被执行一次。测试用例旨在触发每个语句

确保每个代码语句至少被执行一次。测试用例旨在覆盖代码中的每个语句，以验证系统的基本功能。

### 判定覆盖（Decision Coverage）

测试用例旨在覆盖代码中的所有判定条件，包括真和假两种情况

也称为分支覆盖，确保每个判定的每个可能结果至少被执行一次。这有助于验证程序的所有分支和逻辑条件。

### 条件覆盖（Condition Coverage）

确保每个逻辑条件的每个可能结果至少被执行一次。这有助于确保程序中的所有逻辑条件都被正确处理。

### 条件组合覆盖

测试用例旨在覆盖每个条件的所有可能取值，以确保每个条件的真假都被测试到

### 路径覆盖（Path Coverage）

测试用例旨在覆盖程序的所有可能执行路径，以确保每个路径都被执行到

确保程序中的每个可能路径至少被执行一次。这是一种更全面的测试方法，旨在覆盖代码中的所有可能执行路径。

# 4 单元测试

# 5 集成测试

# 6 系统测试

# 7 验收测试

# 8 接口测试

## 接口风格

### 传统风格

### RESTful风格

# 9 自动化测试
